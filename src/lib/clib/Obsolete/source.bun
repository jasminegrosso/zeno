# To unbundle, sh this file
echo datatypes.h 1>&2
cat >datatypes.h <<'End of datatypes.h'
/*
 * datatypes.h: include file for data type package.
 */

#ifndef _datatypes_h
#define _datatypes_h

//  ___________________________________________________
//  Basic data types, and synonyms for bools and reals.
                                
#define AnyType    "a"          // anything at all
#define CharType   "c"          // printable chars
#define ByteType   "b"          // unsigned 8-bit
#define ShortType  "s"          // short integers
#define IntType    "i"          // standard integers
#define LongType   "l"          // long integers
#define FloatType  "f"          // short floating
#define DoubleType "d"          // long floating
 
#define BoolType ShortType      // true/false values
 
#if defined(SINGLEPREC) || defined(MIXEDPREC)
#  define RealType FloatType    // short floating point
#else
#  define RealType DoubleType   // long floating point
#endif
 
//  ________________________________________
//  Utility functions for data type package.

int type_length(string);			// length of data in bytes

string type_name(string);			// C name of basic type

string name_type(string);			// basic type of C name

string type_fmt(string, bool);			// formatting for printf

string type_base(string);			// base of compound type

#endif  // ! _datatypes_h
End of datatypes.h
echo filestruct.h 1>&2
cat >filestruct.h <<'End of filestruct.h'
/*
 * filestruct.h: interface to structured binary file package.
 *       Version 1 by Josh Barnes & Lyman Hurd, IAS, 1987.
 *       Version 2 by Josh Barnes, IAS, 1988.
 *       Version 3 by Josh Barnes, IfA, March 1994.
 */
 
#ifndef _filestruct_h
#define _filestruct_h
 
#include "datatypes.h"
 
#define SetType    "("          // begin compound item
#define TesType    ")"          // end of compound item

//  __________________________________________
//  Routines for direction-symmetric I/O code.
 
void copy_item(stream, stream, string);

void put_set(stream, string);
void put_tes(stream, string);
void put_data(stream, string, string, void *, ...);
void put_data_masked(stream, string, string, void *, ...);
void put_data_sub(stream, string, string, int *, void *, int *);
 
void get_set(stream, string);
void get_tes(stream, string);
void get_data(stream, string, string, void *, ...);
void get_data_masked(stream, string, string, void *, ...);
void get_data_sub(stream, string, string, int *, void *, int *);
 
void put_string(stream, string, string);
string get_string(stream, string);

//  ____________________________________
//  Routines for data-driven input code.
 
bool get_tag_ok(stream, string);
 
string get_type(stream, string);
int *get_dimensions(stream, string);
int get_length(stream, string);

string next_item_tag(stream);
bool skip_item(stream);
 
//  _________________________________________
//  Assorted control routines and parameters.
 
void strclose(stream);
 
void fs_options(int, int);

#define NoChange  0		// don't change setting
#define NotAllow  1		// forbid operation
#define WarnEach  2		// warn user each time
#define WarnOnce  3		// warn user first time
#define SilentOK  4		// allow without warning
 
#endif  // !  _filestruct_h
End of filestruct.h
echo getparam.h 1>&2
cat >getparam.h <<'End of getparam.h'
/*
 * getparam.h: include file for command-line processing.
 */

#ifndef _getparam_h
#define  _getparam_h

void initparam(string *argv, string *defv);	// initialize param package

string getparam(string name);			// return value as string

int getiparam(string name);			// return value as int

bool getbparam(string name);			// return value as boolean

double getdparam(string name);			// return value as double

//  _____________________________________________
//  Macros to obtain name and version of program.

#define getprog()     (getparam("argv0"))	// return name of program
#define getargv0()    (getparam("argv0"))	// return name of program

#define getversion()  (getparam("VERSION"))	// return version as string

//  ___________________________________________
//  Function to inquire about parameter status.

int getparamstat(string name);			// return status flags

//  ________________________________
//  Bits for parameter status flags.

#define DEFPARAM	001			// param has default value

#define REQPARAM	002			// must be given a value

#define ARGPARAM	004			// value reset by argument

#define INPARAM		010			// param used for input

#define OUTPARAM	020			// param used for output

#endif  // ! _getparam_h
End of getparam.h
echo mathfns.h 1>&2
cat >mathfns.h <<'End of mathfns.h'
/*
 * mathfns.h: header file for system and zeno math functions; assumes
 * role of <math.h>.  Defines real-valued synonyms for system
 * functions (eg, rsqrt for square root) and zeno functions (eg,
 * seval), depending on precision switch (MIXEDPREC, SINGLEPREC, or
 * DOUBLEPREC).
 */

#ifndef _mathfns_h
#define _mathfns_h

#include <math.h>

//  System math functions.  Use double-precision versions in both
//  double and mixed precision.

#if defined(DOUBLEPREC) || defined(MIXEDPREC)
#define rsqrt    sqrt
#define rcbrt    cbrt
#define rsin     sin
#define rcos     cos
#define rtan     tan
#define rasin    asin
#define racos    acos
#define ratan    atan
#define ratan2   atan2
#define rlog     log
#define rexp     exp
#define rlog10   log10
#define rsinh    sinh
#define rcosh    cosh
#define rtanh    tanh
#define rpow     pow
#define rabs     fabs
#define rfloor   floor
#define rceil    ceil
#endif

//  System math functions.  Single precision is supplied in two forms,
//  depending on the naming convention.

#if defined(SINGLEPREC)

#if defined(LINUX) || defined(MACOSX)

#define rsqrt    sqrtf
#define rsin     sinf
#define rcos     cosf
#define rtan     tanf
#define rasin    asinf
#define racos    acosf
#define ratan    atanf
#define ratan2   atan2f
#define rlog     logf
#define rexp     expf
#define rlog10   log10f
#define rsinh    sinhf
#define rcosh    coshf
#define rtanh    tanhf
#define rpow     powf
#define rabs     fabsf
#define rfloor   floorf
#define rceil    ceilf

#else

#define rsqrt    fsqrt
#define rsin     fsin
#define rcos     fcos
#define rtan     ftan
#define rasin    fasin
#define racos    facos
#define ratan    fatan
#define ratan2   fatan2
#define rlog     flog
#define rexp     fexp
#define rlog10   log10f
#define rsinh    fsinh
#define rcosh    fcosh
#define rtanh    ftanh
#define rpow     powf
#define rabs     fabsf
#define rfloor   ffloor
#define rceil    fceil

#endif

#endif

//  Functions in mathfns.c; invoked just like those above.

#if defined(DOUBLEPREC) || defined(MIXEDPREC)

#define rsqr     sqr
#define rqbe     qbe
#define rdex     dex
#define rlog2    log2
#define rexp2    exp2

double sqr(double);
double qbe(double);
double dex(double);

#if !defined(MACOSX)
double log2(double);
double exp2(double);
#endif

#else

#define rsqr     fsqr
#define rqbe     fqbe
#define rcbrt    fcbrt
#define rdex     fdex
#define rlog2    flog2
#define rexp2    fexp2

float fsqr(float);
float fqbe(float);
float fcbrt(float);
float fdex(float);
float flog2(float);
float fexp2(float);

#endif

//  Bessel functions available only in double precision.

double bessel_I0(double x);
double bessel_I1(double x);
double bessel_K0(double x);
double bessel_K1(double x);
double bessel_I(double nu, double x);
double bessel_K(double nu, double x);

//  Random number functions return double-precision values.

void init_random(unsigned long seed);
double xrandom(double xl, double xh);
double grandom(double mean, double sdev);
void get_random_state(int *nb, void **st);
void set_random_state(int *nb, void **st);

//  Functions which traffic in pointers to real values must be
//  provided in all three variants.  See also "vectdefs.h".

#if defined(DOUBLEPREC)
#define pickshell dpickshell
#define pickball  dpickball
#define pickbox   dpickbox
#define setrange  dsetrange
#define spline    dspline
#define seval     dseval
#define spldif    dspldif
#endif

#if defined(MIXEDPREC)
#define pickshell mpickshell
#define pickball  mpickball
#define pickbox   mpickbox
#define setrange  msetrange
#define spline    mspline
#define seval     mseval
#define spldif    mspldif
#endif

#if defined(SINGLEPREC)
#define pickshell fpickshell
#define pickball  fpickball
#define pickbox   fpickbox
#define setrange  fsetrange
#define spline    fspline
#define seval     fseval
#define spldif    fspldif
#endif

//  Functions in pickpnt.c

void pickshell(real *, int, real);
void pickball(real *, int, real);
void pickbox(real *, int, real);

//  Functions in spline.c

void spline(real *, real *, real *, int);
real seval(real, real *, real *, real *, int);
real spldif(real, real *, real *, real *, int);

//  Functions in setrange.c

void setrange(real *, string);

#endif  // ! _mathfns_h
End of mathfns.h
echo phatstruct.h 1>&2
cat >phatstruct.h <<'End of phatstruct.h'
/*
 * phatstruct.h: definitions for "phat" structures.
 */

#ifndef _phatstruct_h
#define _phatstruct_h

//  ___________________________________________________________________
//  ps_field: structure describing one element of a phat structure.  A
//  phat structure is described by an array of ps_fields.  The zeroth
//  field refers to the entire structure and its length is the length
//  of the whole structure.  The array is terminated by a ps_field with
//  a NULL name.  Compound data types are supported, but they must be
//  homogenious.

typedef struct {
    string type;		// type code following "datatypes.h"
    string name;		// text for name of field
    int offset;			// offset in bytes from start of struct
    int length;			// length in bytes of this field
} ps_field;

//  _____________________________________________________________________
//  badoffset: offset value for structure fields which aren't actualized.

#define BadOffset  -1

//  __________________________________________________________________________
//  layout_struct: compute offsets and length for structure with named fields.

void layout_struct(ps_field *, string *);

//  _____________________________________________________
//  new_field: define a new field of given type and name.

void new_field(ps_field *, string, string);

//  ________________________________________________________________________
//  define_struct, define_offset: describe total length and individual field
//  offsets of static structure.

void define_struct(ps_field *, string, int);
void define_offset(ps_field *, string, int);

//  ________________________
//  Generic selector macros.

#define SelectByte(p,o)    (*((byte *) ((byte *)(p) + (o))))
#define SelectChar(p,o)    (*((char *) ((byte *)(p) + (o))))
#define SelectShort(p,o)   (*((short *) ((byte *)(p) + (o))))
#define SelectBool(p,o)    (*((bool *) ((byte *)(p) + (o))))
#define SelectInt(p,o)     (*((int *) ((byte *)(p) + (o))))
#define SelectLong(p,o)    (*((long *) ((byte *)(p) + (o))))
#define SelectFloat(p,o)   (*((float *) ((byte *)(p) + (o))))
#define SelectDouble(p,o)  (*((double *) ((byte *)(p) + (o))))
#define SelectReal(p,o)    (*((real *) ((byte *)(p) + (o))))
#define SelectVect(p,o)    ((real *) ((byte *)(p) + (o)))

#endif  // ! _phatstruct_h
End of phatstruct.h
echo stdinc.h 1>&2
cat >stdinc.h <<'End of stdinc.h'
/* 
 * stdinc.h: standard include file for Zeno C programs.
 * Copyright (c) 2012  Josh Barnes  Honolulu, HI.
 */

#ifndef _stdinc_h
#define _stdinc_h

//  Always include stdio.h and stdlib.h.

#include <stdio.h>
#include <stdlib.h>

//  ___________________________________________________________
//  NULL: value for null pointers, normally defined by stdio.h.

#if !defined(NULL)
#  define NULL 0L
#endif

//  _______________________________________________________________________
//  local: synonym for static declares an object as local to a source file.

#define local static

//  _____________________________________________________
//  bool, TRUE, FALSE: standard names for logical values.

typedef short int bool;

#if !defined(TRUE)
#  define TRUE  ((bool) 1)
#  define FALSE ((bool) 0)
#endif

//  _________________________________
//  byte: name a handy chunk of bits.

typedef unsigned char byte;

//  ___________________________________
//  string: null-terminated char array.

typedef char *string;

//  ________________________________________
//  stream: more elegant synonym for FILE *.

typedef FILE *stream;			// note: stdio.h is included above

//  ____________________________________________________________________
//  real, realptr: Compile-time precision specification.  Options are:
//      DOUBLEPREC:     everything (variables & functions) is double.
//      MIXEDPREC:      user values are float, -lm functions are double.
//      SINGLEPREC:     everything (variables & functions) is float.
//  See <mathfns.h> for a list of real-valued functions.  If single
//  precision library functions are not availible then use MIXEDPREC
//  instead of SINGLEPREC.

//  Default precision is SINGLEPREC on LINUX and SGI, and MIXEDPREC on Sun.

#if !defined(MIXEDPREC) && !defined(SINGLEPREC) && !defined(DOUBLEPREC)
#  if !defined(SUN)
#    define SINGLEPREC
#  else
#    define MIXEDPREC
#  endif
#endif

#if defined(DOUBLEPREC)
#  undef SINGLEPREC
#  undef MIXEDPREC
   typedef double real, *realptr;
#  define Precision "DOUBLEPREC"
#endif

#if defined(MIXEDPREC)
#  undef DOUBLEPREC
#  undef SINGLEPREC
   typedef float *realptr, real;
#  define Precision "MIXEDPREC"
#endif

#if defined(SINGLEPREC)
#  undef DOUBLEPREC
#  undef MIXEDPREC
   typedef float real, *realptr;
#  define Precision "SINGLEPREC"
#endif

//  _________________________________
//  PI, etc.: mathematical constants.

#define PI         3.14159265358979323846
#define TWO_PI     6.28318530717958647693
#define FOUR_PI   12.56637061435917295385
#define HALF_PI    1.57079632679489661923
#define FRTHRD_PI  4.18879020478639098462

//  _________________________________________________________________
//  streq, strne: string-equality macros. strnull: test empty string.
//  Note that string.h should be included before these are used.

#define streq(x,y) (strcmp((x), (y)) == 0)
#define strne(x,y) (strcmp((x), (y)) != 0)
#define strnull(x) (strcmp((x), "") == 0)

//  _________________________________________________
//  ABS: returns the absolute value of its argument.
//  MAX: returns the argument with the highest value.
//  MIN: returns the argument with the lowest value.

#define ABS(x)   (((x)<0)?-(x):(x))
#define MAX(a,b) (((a)>(b))?(a):(b))
#define MIN(a,b) (((a)<(b))?(a):(b))

//  Prototypes for misc. functions in Clib.

void *allocate(int);			// alloc, zero, & check for errors

string *burststring(string, string);	// burst string into token list

double cputime(void);			// returns CPU time in minutes

void set_error_stream(stream);		// send error msgs to given stream
void error(string, ...);		// complain about error and exit
void fatal(string, ...);		// complain about error and abort
void eprintf(string, ...);		// print message to stderr	

void *getxstr(stream, int);		// read extended string
bool putxstr(stream, void *, int);	// write extended string	
void *copxstr(void *, int);		// make copy of extended string
int xstrlen(void *, int);		// find length of extended string
bool xstreq(void *, void *, int);	// compare extended strings

bool scanopt(string, string);		// scan options for keyword

stream stropen(string, string);		// arguments are much like fopen

void get_history(stream);		// read history data from stream
void put_history(stream);		// write history data to stream
void add_history(string);		// append item to history data
string *ask_history(void);		// return vector of history entries

bool within(double, string, double);	// test if value lies in range(s)

#endif  // ! _stdinc_h
End of stdinc.h
echo strset.h 1>&2
cat >strset.h <<'End of strset.h'
/*
 * strset.h: definitions for simple package for string sets.
 */

#ifndef _strset_h
#define _strset_h

//  ___________________________________________________________________
//  Sets are represented by null-terminated vectors of string pointers.

string *set_cons(string, ...);

string *set_copy(string *);

int set_length(string *);

bool set_member(string *, string);

bool set_equal(string *, string *);

bool set_subset(string *, string *);

string *set_union(string *, string *);

string *set_inter(string *, string *);

string *set_diff(string *, string *);

#endif // ! _strset_h
End of strset.h
echo vectdefs.h 1>&2
cat >vectdefs.h <<'End of vectdefs.h'
/*
 * vectdefs.h: definitions from vectmath.h, separated for programs which
 * need to define vectors without loading the whole mess of definitions.
 */

#ifndef _vectdefs_h
#define _vectdefs_h

#if !defined(NDIM) && !defined(TWODIM) && !defined(THREEDIM)
#define THREEDIM			      // specify default dimensions
#endif

#if defined(THREEDIM) || (NDIM==3)
#undef  TWODIM
#define NDIM 3
#define THREEDIM
#endif

#if defined(TWODIM) || (NDIM==2)
#undef  THREEDIM
#define NDIM 2
#define TWODIM
#endif

typedef real vector[NDIM];
typedef real matrix[NDIM][NDIM];

//  ____________________________________________________________________
//  Scalar-valued vector functions.  These pass the number of dimensions
//  as the last argument so they will work with any value of NDIM.

#define dotvp(v,u) (_dotvp((real*)(v),(real*)(u),NDIM))
#define absv(v)    (_absv((real*)(v),NDIM))
#define distv(v,u) (_distv((real*)(v),(real*)(u),NDIM))
#define tracem(p)  (_tracem((real*)(p),NDIM))

#if defined(MIXEDPREC)
#define _dotvp  _mdotvp
#define _absv   _mabsv
#define _distv  _mdistv
#define _tracem _mtracem
#endif

#if defined(SINGLEPREC)
#define _dotvp  _fdotvp
#define _absv   _fabsv
#define _distv  _fdistv
#define _tracem _ftracem
#endif

#if defined(DOUBLEDPREC)
#define _dotvp  _ddotvp
#define _absv   _dabsv
#define _distv  _ddistv
#define _tracem _dtracem
#endif

real _dotvp(real *, real *, int);
real _absv(real *, int);
real _distv(real *, real *, int);
real _tracem(real *, int);

//  ______________________________________________________
//  VectType: Datatypes-style type for 3-D or 2-D vectors.

#ifdef THREEDIM
#define VectType  (RealType RealType RealType)
#else
#define VectType  (RealType RealType)
#endif

#endif  // ! _vectdefs_h
End of vectdefs.h
echo vectmath.h 1>&2
cat >vectmath.h <<'End of vectmath.h'
/*
 * vectmath.h: include file for vector/matrix operations.
 */

#ifndef _vectmath_h
#define _vectmath_h

#include "vectdefs.h"

//  __________________
//  Vector operations.

#define CLRV(v)			// CLeaR Vector
{									\
    int _i;								\
    for (_i = 0; _i < NDIM; _i++)					\
        (v)[_i] = 0.0;							\
}

#define UNITV(v,j)		// UNIT Vector
{									\
    int _i;								\
    for (_i = 0; _i < NDIM; _i++)					\
        (v)[_i] = (_i == (j) ? 1.0 : 0.0);				\
}

#define SETV(v,u)		// SET Vector
{ 									\
    int _i; 								\
    for (_i = 0; _i < NDIM; _i++) 					\
        (v)[_i] = (u)[_i]; 						\
}

#ifdef THREEDIM

#define DOTVP(s,v,u)		// DOT Vector Product
{									\
    (s) = (v)[0]*(u)[0] + (v)[1]*(u)[1] + (v)[2]*(u)[2];		\
}

#else

#define DOTVP(s,v,u)		// DOT Vector Product
{									\
    int _i;								\
    (s) = 0.0;								\
    for (_i = 0; _i < NDIM; _i++)					\
        (s) += (v)[_i] * (u)[_i];					\
}

#endif

#define ABSV(s,v)		// ABSolute value of a Vector
{									\
    real _tmp;		                                                \
    int _i;								\
    _tmp = 0.0;								\
    for (_i = 0; _i < NDIM; _i++)					\
        _tmp += (v)[_i] * (v)[_i];					\
    (s) = rsqrt(_tmp);                                                  \
}

#ifdef THREEDIM

#define ADDV(v,u,w)		// ADD Vector
{									\
    (v)[0] = (u)[0] + (w)[0];						\
    (v)[1] = (u)[1] + (w)[1];						\
    (v)[2] = (u)[2] + (w)[2];						\
}

#define SUBV(v,u,w)		// SUBtract Vector
{									\
    (v)[0] = (u)[0] - (w)[0];						\
    (v)[1] = (u)[1] - (w)[1];						\
    (v)[2] = (u)[2] - (w)[2];						\
}

#define MULVS(v,u,s)		// MULtiply Vector by Scalar
{									\
    (v)[0] = (u)[0] * (s);						\
    (v)[1] = (u)[1] * (s);						\
    (v)[2] = (u)[2] * (s);						\
}

#define DIVVS(v,u,s)		// DIVide Vector by Scalar
{									\
    (v)[0] = (u)[0] / (s);						\
    (v)[1] = (u)[1] / (s);						\
    (v)[2] = (u)[2] / (s);						\
}

#else

#define ADDV(v,u,w)		// ADD Vector
{									\
    int _i;								\
    for (_i = 0; _i < NDIM; _i++)					\
        (v)[_i] = (u)[_i] + (w)[_i];					\
}

#define SUBV(v,u,w)		// SUBtract Vector
{									\
    int _i;								\
    for (_i = 0; _i < NDIM; _i++)					\
        (v)[_i] = (u)[_i] - (w)[_i];					\
}

#define MULVS(v,u,s)		// MULtiply Vector by Scalar
{									\
    int _i;								\
    for (_i = 0; _i < NDIM; _i++)					\
        (v)[_i] = (u)[_i] * (s);					\
}

#define DIVVS(v,u,s)		// DIVide Vector by Scalar
{									\
    int _i;								\
    for (_i = 0; _i < NDIM; _i++)					\
        (v)[_i] = (u)[_i] / (s);					\
}

#endif

#define DISTV(s,u,v)		// DISTance between Vectors
{									\
    real _tmp;                                                		\
    int _i;								\
    _tmp = 0.0;								\
    for (_i = 0; _i < NDIM; _i++)					\
        _tmp += ((u)[_i]-(v)[_i]) * ((u)[_i]-(v)[_i]);		        \
    (s) = rsqrt(_tmp);                                                  \
}

#ifdef THREEDIM

#define DISTSQV(s,u,v)		// DISTance SQuared between Vectors
{									\
    real _dx, _dy, _dz;							\
    _dx = (u)[0] - (v)[0];						\
    _dy = (u)[1] - (v)[1];						\
    _dz = (u)[2] - (v)[2];						\
    (s) = _dx*_dx + _dy*_dy + _dz*_dz;					\
}

#else

#define DISTSQV(s,u,v)		// DISTance SQuared between Vectors
{									\
    int _i;								\
    (s) = 0.0;								\
    for (_i = 0; _i < NDIM; _i++)					\
        (s) += ((u)[_i]-(v)[_i]) * ((u)[_i]-(v)[_i]);		        \
}

#endif

#ifdef TWODIM

#define CROSSVP(s,v,u)		// CROSS Vector Product
{									\
    (s) = (v)[0]*(u)[1] - (v)[1]*(u)[0];				\
}

#endif

#ifdef THREEDIM

#define CROSSVP(v,u,w)		// CROSS Vector Product
{									\
    (v)[0] = (u)[1]*(w)[2] - (u)[2]*(w)[1];				\
    (v)[1] = (u)[2]*(w)[0] - (u)[0]*(w)[2];				\
    (v)[2] = (u)[0]*(w)[1] - (u)[1]*(w)[0];				\
}

#endif

//  __________________
//  Matrix operations.

#define CLRM(p)			// CLeaR Matrix
{									\
    int _i, _j;								\
    for (_i = 0; _i < NDIM; _i++)					\
        for (_j = 0; _j < NDIM; _j++)					\
	    (p)[_i][_j] = 0.0;						\
}

#define SETMI(p)		// SET Matrix to Identity
{									\
    int _i, _j;								\
    for (_i = 0; _i < NDIM; _i++)					\
        for (_j = 0; _j < NDIM; _j++)					\
	    (p)[_i][_j] = (_i == _j ? 1.0 : 0.0);			\
}

#define SETM(p,q)		// SET Matrix
{									\
    int _i, _j;								\
    for (_i = 0; _i < NDIM; _i++)					\
        for (_j = 0; _j < NDIM; _j++)					\
	    (p)[_i][_j] = (q)[_i][_j];					\
}

#define TRANM(p,q)		// TRANspose Matrix
{									\
    int _i, _j;								\
    for (_i = 0; _i < NDIM; _i++)					\
        for (_j = 0; _j < NDIM; _j++)					\
	    (p)[_i][_j] = (q)[_j][_i];					\
}

#define ADDM(p,q,r)		// ADD Matrix
{									\
    int _i, _j;								\
    for (_i = 0; _i < NDIM; _i++)					\
        for (_j = 0; _j < NDIM; _j++)					\
	    (p)[_i][_j] = (q)[_i][_j] + (r)[_i][_j];			\
}

#define SUBM(p,q,r)		// SUBtract Matrix
{									\
    int _i, _j;								\
    for (_i = 0; _i < NDIM; _i++)					\
        for (_j = 0; _j < NDIM; _j++)					\
	    (p)[_i][_j] = (q)[_i][_j] - (r)[_i][_j];			\
}

#define MULM(p,q,r)		// Multiply Matrix
{									\
    int _i, _j, _k;							\
    for (_i = 0; _i < NDIM; _i++)					\
	for (_j = 0; _j < NDIM; _j++) {					\
	    (p)[_i][_j] = 0.0;						\
            for (_k = 0; _k < NDIM; _k++)				\
		(p)[_i][_j] += (q)[_i][_k] * (r)[_k][_j];		\
        }								\
}

#define MULMS(p,q,s)		// MULtiply Matrix by Scalar
{									\
    int _i, _j;								\
    for (_i = 0; _i < NDIM; _i++)				        \
        for (_j = 0; _j < NDIM; _j++)					\
	    (p)[_i][_j] = (q)[_i][_j] * (s);				\
}

#define DIVMS(p,q,s)		// DIVide Matrix by Scalar
{									\
    int _i, _j;								\
    for (_i = 0; _i < NDIM; _i++)					\
        for (_j = 0; _j < NDIM; _j++)					\
	    (p)[_i][_j] = (q)[_i][_j] / (s);				\
}

#define MULMV(v,p,u)		// MULtiply Matrix by Vector
{									\
    int _i, _j;								\
    for (_i = 0; _i < NDIM; _i++) {					\
	(v)[_i] = 0.0;							\
	for (_j = 0; _j < NDIM; _j++)					\
	    (v)[_i] += (p)[_i][_j] * (u)[_j];				\
    }									\
}

#define MULMV1(v,p,u)		// MULtiply Matrix by Vector
{				// args v, u may be identical
    int _i, _j;								\
    vector _tmp;							\
    for (_i = 0; _i < NDIM; _i++) {					\
	_tmp[_i] = 0.0;							\
	for (_j = 0; _j < NDIM; _j++)					\
	    _tmp[_i] += (p)[_i][_j] * (u)[_j];				\
    }									\
    for (_i = 0; _i < NDIM; _i++)					\
        (v)[_i] = _tmp[_i];						\
}

#define OUTVP(p,v,u)		// OUTer Vector Product
{									\
    int _i, _j;								\
    for (_i = 0; _i < NDIM; _i++)					\
        for (_j = 0; _j < NDIM; _j++)					\
	    (p)[_i][_j] = (v)[_i] * (u)[_j];				\
}

#define TRACEM(s,p)		// TRACE of Matrix
{									\
    int _i;								\
    (s) = 0.0;								\
    for (_i = 0.0; _i < NDIM; _i++)					\
	(s) += (p)[_i][_i];						\
}

//  ____________________________
//  Enhancements for tree codes.

#ifdef THREEDIM

#define DOTPSUBV(s,v,u,w)	// SUB Vectors, form DOT Prod
{									\
    (v)[0] = (u)[0] - (w)[0];    (s)  = (v)[0] * (v)[0];		\
    (v)[1] = (u)[1] - (w)[1];    (s) += (v)[1] * (v)[1];		\
    (v)[2] = (u)[2] - (w)[2];    (s) += (v)[2] * (v)[2];		\
}

#define DOTPMULMV(s,v,p,u)	// MUL Mat by Vect, form DOT Prod
{									\
    DOTVP(v[0], p[0], u);    (s)  = (v)[0] * (u)[0];			\
    DOTVP(v[1], p[1], u);    (s) += (v)[1] * (u)[1];			\
    DOTVP(v[2], p[2], u);    (s) += (v)[2] * (u)[2];			\
}

#define ADDMULVS(v,u,s)		// MUL Vect by Scalar, ADD to vect
{									\
    (v)[0] += (u)[0] * (s);						\
    (v)[1] += (u)[1] * (s);						\
    (v)[2] += (u)[2] * (s);						\
}

#define ADDMULVS2(v,u,s,w,r)	// 2 times MUL V by S, ADD to vect
{									\
    (v)[0] += (u)[0] * (s) + (w)[0] * (r);				\
    (v)[1] += (u)[1] * (s) + (w)[1] * (r);				\
    (v)[2] += (u)[2] * (s) + (w)[2] * (r);				\
}

#endif

//  ________________________
//  Misc. impure operations.

#define SETVS(v,s)		// SET Vector to Scalar
{									\
    int _i;								\
    for (_i = 0; _i < NDIM; _i++)					\
        (v)[_i] = (s);							\
}

#define ADDVS(v,u,s)		// ADD Vector and Scalar
{									\
    int _i;								\
    for (_i = 0; _i < NDIM; _i++)					\
        (v)[_i] = (u)[_i] + (s);					\
}

#define SETMS(p,s)		// SET Matrix to Scalar
{									\
    int _i, _j;								\
    for (_i = 0; _i < NDIM; _i++)					\
        for (_j = 0; _j < NDIM; _j++)					\
	    (p)[_i][_j] = (s);						\
}

#endif  // ! _vectmath_h
End of vectmath.h
echo allocate.c 1>&2
cat >allocate.c <<'End of allocate.c'
/*
 * allocate.c: memory allocation and zeroing, with error checking.
 */

#include "stdinc.h"
#include "getparam.h"

void *allocate(int nb)
{
  void *mem;

  if (nb <= 0)
    error("%s.allocate: absurd request (nb = %d)\n", getprog(), nb);
  mem = calloc(nb, 1);			// use calloc to zero mem
  if (mem == NULL)
    error("%s.allocate: not enough memory (nb = %d)\n", getprog(), nb);
  return (mem);
}
End of allocate.c
echo bessel.c 1>&2
cat >bessel.c <<'End of bessel.c'
/*
 * bessel.c: interfaces to gsl bessel functions provide error checking.
 */

#include "stdinc.h"
#include "getparam.h"

#include <gsl/gsl_sf_bessel.h>

//  ______________________________________________________________________
//  bessel_I0: regular modified cylindrical Bessel function I, order zero.

double bessel_I0(double x)
{
  gsl_sf_result res;
  int stat;

  stat = gsl_sf_bessel_I0_e(x, &res);
  if (stat != 0)
    error("%s.bessel_I0: error status: %s\n", getprog(), gsl_strerror(stat));
  return (res.val);
}

//  _____________________________________________________________________
//  bessel_I1: regular modified cylindrical Bessel function I, order one.

double bessel_I1(double x)
{
  gsl_sf_result res;
  int stat;

  stat = gsl_sf_bessel_I1_e(x, &res);
  if (stat != 0)
    error("%s.bessel_I1: error status: %s\n", getprog(), gsl_strerror(stat));
  return (res.val);
}

//  ___________________________________________________________________
//  bessel_I: regular modified cylindrical Bessel function I, order nu.

double bessel_I(double nu, double x)
{
  gsl_sf_result res;
  int stat;

  stat = gsl_sf_bessel_Inu_e(nu, x, &res);
  if (stat != 0)
    error("%s.bessel_I: error status: %s\n", getprog(), gsl_strerror(stat));
  return (res.val);
}

//  ________________________________________________________________________
//  bessel_K0: irregular modified cylindrical Bessel function K, order zero.

double bessel_K0(double x)
{
  gsl_sf_result res;
  int stat;

  stat = gsl_sf_bessel_K0_e(x, &res);
  if (stat != 0)
    error("%s.bessel_K0: error status: %s\n", getprog(), gsl_strerror(stat));
  return (res.val);
}

//  _______________________________________________________________________
//  bessel_K1: irregular modified cylindrical Bessel function K, order one.

double bessel_K1(double x)
{
  gsl_sf_result res;
  int stat;

  stat = gsl_sf_bessel_K1_e(x, &res);
  if (stat != 0)
    error("%s.bessel_K1: error status: %s\n", getprog(), gsl_strerror(stat));
  return (res.val);
}

//  _____________________________________________________________________
//  bessel_K: irregular modified cylindrical Bessel function K, order nu.

double bessel_K(double nu, double x)
{
  gsl_sf_result res;
  int stat;

  stat = gsl_sf_bessel_Knu_e(nu, x, &res);
  if (stat != 0)
    error("%s.bessel_k: error status: %s\n", getprog(), gsl_strerror(stat));
  return (res.val);
}

#if defined(TESTBED)

#include "mathfns.h"

string defv[] = {		";Test bessel functions",
  "x=4.5",			";Argument for functions",
  "nu=0.5",			";Order for functions",
  "VERSION=1.0",		";Joshua Barnes  11 May 2012",    
  NULL,
};

int main(int argc, string argv[])
{
  double x, nu, ex;

  initparam(argv, defv);
  x = getdparam("x");
  nu = getdparam("nu");
  ex = exp(x);
  printf("bessel_I0(%f) = %f\t%f\n", x, bessel_I0(x), bessel_I0(x) / ex);
  printf("bessel_I1(%f) = %f\t%f\n", x, bessel_I1(x), bessel_I1(x) / ex);
  printf("bessel_K0(%f) = %f\t%f\n", x, bessel_K0(x), ex * bessel_K0(x));
  printf("bessel_K1(%f) = %f\t%f\n", x, bessel_K1(x), ex * bessel_K1(x));
  printf("bessel_I(%f,%f) = %f\t%f\n",
	 nu, x, bessel_I(nu, x), bessel_I(nu, x) / ex);
  printf("bessel_K(%f,%f) = %f\t%f\n",
	 nu, x, bessel_K(nu, x), bessel_K(nu, x) / ex);
  return (0);
}

#endif
End of bessel.c
echo burststring.c 1>&2
cat >burststring.c <<'End of burststring.c'
/*
 * burststring.c: break a string of the form "word1, word2, ..." into
 * seperate strings "word1", "word2", ... and return them in an
 * extended-string (ie, NULL-terminated sequence of pointers).
 */

#include "stdinc.h"
#include "getparam.h"
#include <string.h>

#define MWRD  64	// max words in list
#define MSTR 256	// max chars per word

string *burststring(string lst, string sep)
{
  string wrdbuf[MWRD], *wp;
  char strbuf[MSTR], *sp, *lp;

  wp = wrdbuf;
  sp = strbuf;
  lp = lst;
  do {							// scan over string
    if (*lp == (char) NULL ||
	  strchr(sep, *lp) != NULL) {			// is this a sep?
      if (sp > strbuf) {				// and got a word?
	*sp = (char) NULL;
	*wp++ = (string) copxstr(strbuf, sizeof(char));
	if (wp == &wrdbuf[MWRD])			// no room in buf?
	  error("%s.burststring: too many words\n", getprog());
	sp = strbuf;					// ready for next
      }
    } else {						// part of word
      *sp++ = *lp;					// so copy it over
      if (sp == &strbuf[MSTR])				// no room left?
	error("%s.burststring: word too long\n", getprog());
    }
  } while (*lp++ != (char) NULL);			// until list ends
  *wp = NULL;						// end word list
  return ((string *) copxstr(wrdbuf, sizeof(string)));
}

#ifdef TESTBED

string defv[] = {
    "lst=foo, bar,waldo ,",
    "sep= ,",
    NULL,
};

main(argc, argv)
int argc;
string argv[];
{
    string getparam(), lst, sep, *wrds;

    initparam(argv, defv);
    lst = getparam("lst");
    sep = getparam("sep");
    wrds = burststring(lst, sep);
    while (*wrds != NULL)
	printf("\"%s\"  ", *wrds++);
    printf("\n");
}

#endif
End of burststring.c
echo cputime.c 1>&2
cat >cputime.c <<'End of cputime.c'
/*
 * cputime.c: compute total process CPU time in minutes.
 */

#include "stdinc.h"
#include "getparam.h"

#if !defined(OBSOLETE_CODE)

#include <sys/time.h>
#include <sys/resource.h>

double cputime(void)
{
  struct rusage buf;

  if (getrusage(RUSAGE_SELF, &buf) == -1)
    error("%s.cputime: getrusage() call failed\n", getprog());
  return ((buf.ru_utime.tv_sec + buf.ru_utime.tv_usec / 1000000.0 +
	   buf.ru_stime.tv_sec + buf.ru_stime.tv_usec / 1000000.0) / 60.0);
}

#else

#include <sys/types.h>
#include <sys/times.h>
#include <sys/param.h>

double cputime(void)
{
    struct tms buffer;

    if (times(&buffer) == -1)
	error("%s.cputime: times() call failed\n", getprog());
    return ((buffer.tms_utime + buffer.tms_stime) / (60.0 * HZ));
}

#endif
End of cputime.c
echo datatypes.c 1>&2
cat >datatypes.c <<'End of datatypes.c'
/*
 * datatypes.c: table and utility routines for data type package.
 */

#include "stdinc.h"
#include "getparam.h"
#include "datatypes.h"
#include <string.h>

//  ___________________________________________
//  typeinfo: struct for info about data types.

typedef struct {
    string type;				// name from datatypes.h
    string name;				// C-style decleration
    string fmt1;				// low-precision format
    string fmt2;				// high-precision format
    int size;					// size of type in bytes
} typeinfo;

//  ____________________________________________________
//  typetable: table of basic types and associated data.

local typeinfo typetable[] = {
  { AnyType,    "any",    "%#o",  "%#o",     sizeof(byte),   },
  { CharType,   "char",   "%c",   "%c",      sizeof(char),   },
  { ByteType,   "byte",   "%#o",  "%#o",     sizeof(byte),   },
  { ShortType,  "short",  "%#o",  "%#o",     sizeof(short),  },
  { IntType,    "int",    "%#o",  "%#o",     sizeof(int),    },
  { LongType,   "long",   "%#lo", "%#lo",    sizeof(long),   },
  { FloatType,  "float",  "%#g",  "%15.8e",  sizeof(float),  },
  { DoubleType, "double", "%#g",  "%23.16e", sizeof(double), },
  { NULL,       NULL,     NULL,   NULL,      0,              },
};

local typeinfo *find_type(string);		// lookup by 1st element
local typeinfo *find_name(string);		// lookup by C-style name

//  __________________________________________________________
//  type_length: compute total size of basic or compound type.

int type_length(string type)
{
    int count;
    char *tp;

    count = 0;
    for (tp = type; *tp != (char) NULL; tp++)	// loop over all elements
	count += find_type(tp)->size;		// add size of each element
    return (count);
}

//  _______________________________________
//  type_name: return C-style name of type.

string type_name(string type)
{
    return (find_type(type)->name);
}

//  _____________________________________________
//  name_type: return basic type of C-style name.

string name_type(string name)
{
    return (find_name(name)->type);
}

//  ________________________________________
//  type_fmt: return format string for type.

string type_fmt(string type, bool lowprec)
{
    return (lowprec ? find_type(type)->fmt1 : find_type(type)->fmt2);
}

//  __________________________________________________________
//  type_base: return basic type of homogenious compound type.

string type_base(string type)
{
    char *tp;

    for (tp = type; *tp != (char) NULL; tp++)
	if (*tp != type[0])
	    error("%s.base_type: type %s inhomogenious\n",
		  getprog(), type);
    return (tp - 1);
}

//  ______________________________________________________________
//  find_type: return typeinfo for given type.  Note: for compound
//  types, the typeinfo for the first element is returned.

local typeinfo *find_type(string type)
{
    typeinfo *tp;

    for (tp = typetable; tp->type != NULL; tp++)
	if (tp->type[0] == type[0])
	    return (tp);
    error("%s.find_type: type %c unknown\n", getprog(), type[0]);
    return (NULL);
}

//  __________________________________________
//  find_name: return typeinfo for named type.

local typeinfo *find_name(string name)
{
    typeinfo *tp;

    for (tp = typetable; tp->type != NULL; tp++)
	if (streq(tp->name, name))
	    return (tp);
    error("%s.find_name: type %s unknown\n", getprog(), name);
    return (NULL);
}

#ifdef TESTBED

string defv[] = {		";Test datatypes routines",
    "type=" IntType,		";Data type string",
    "name=int",			";C-style type name",
    "VERSION=1",		";Josh Barnes  15 October 1997",
    NULL,
};

void main(int argc, string argv[])
{
    string type, name;

    initparam(argv, defv);
    type = getparam("type");
    name = getparam("name");
    printf("type_length(\"%s\") = %d\n", type, type_length(type));
    printf("type_name(\"%s\") = %s\n", type, type_name(type));
    printf("type_base(\"%s\") = %s\n", type, type_base(type));
    printf("type_fmt(\"%s\", TRUE) = %s\n", type, type_fmt(type, TRUE));
    printf("type_fmt(\"%s\", FALSE) = %s\n", type, type_fmt(type, FALSE));
    printf("name_type(\"%s\") = %s\n", name, name_type(name));
}

#endif
End of datatypes.c
echo error.c 1>&2
cat >error.c <<'End of error.c'
/* 
 * error.c: routines to report errors, etc.
 */

#include "stdinc.h"
#include <stdarg.h>

local stream errstr = NULL;			// use to report errors

//  _______________________________________________________
//  set_error_stream: direct error message to given stream.

void set_error_stream(stream str)
{
  errstr = str;
}

//  ______________________________
//  error: scream and die quickly.

void error(string fmt, ...)
{
  va_list ap;

  va_start(ap, fmt);
  vfprintf(stderr, fmt, ap);			// printf msg to std error
  va_end(ap);
  fflush(stderr);
  if (errstr != NULL) {				// error logging enabled
    va_start(ap, fmt);
    vfprintf(errstr, fmt, ap);
    va_end(ap);
    fflush(errstr);
  }
  exit(1);					// quit with error status
}

//  ____________________________________
//  fatal: scream and die an ugly death.

void fatal(string fmt, ...)
{
  va_list ap;

  va_start(ap, fmt);
  vfprintf(stderr, fmt, ap);			// printf msg to std error
  va_end(ap);
  fflush(stderr);
  if (errstr == NULL)				// default to error log
    errstr = fopen("fatal_error.log", "a");
  if (errstr != NULL) {				
    va_start(ap, fmt);
    vfprintf(errstr, fmt, ap);			// printf msg to error str
    va_end(ap);
    fflush(errstr);
  }
  abort();					// quit, leave core image
}

//  ____________________________________________________________________
//  eprintf: print messages and warnings.  Uses "ZENO_MSG_OPT" env. var.
//  to control printing; "warn" or "none" suppress some or all output.


void eprintf(string fmt, ...)
{
  static string msgopt = NULL;
  va_list ap;

  if (msgopt == NULL)				// if NULL, get env. value
    msgopt = getenv("ZENO_MSG_OPT");
  if (! ((msgopt != NULL) &&
	 (streq(msgopt, "none") ||
	  (streq(msgopt, "warn") && strcasestr(fmt, "warn") == NULL)))) {
    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);			// printf msg to std error
    va_end(ap);
    fflush(stderr);				// drain std error buffer
  }
}

#ifdef TESTBED

#include "getparam.h"

string defv[] = {
  "logfile=",
  "fatal=false",
  NULL,
};

int main(int argc, string argv[])
{
  initparam(argv, defv);
  if (!strnull(getparam("logfile")))
    set_error_stream(fopen(getparam("logfile"), "w"));
  eprintf("[%s: foo=%f  bar=%d  fum=\"%s\"]\n",
	  getprog(), 2.7183, 16384, "frodo");
  eprintf("[%s: WARNING: foo=%f  bar=%d  fum=\"%s\"]\n",
	  getprog(), 3.1415, 32768, "bilbo");
  if (! getbparam("fatal"))
    error("error: foo=%f  bar=%d  fum=\"%s\"\n", 0.5772, 65536, "waldo");
  else
    fatal("error: foo=%f  bar=%d  fum=\"%s\"\n", 0.5772, 65536, "waldo");
  return (0);
}

#endif
End of error.c
echo extstring.c 1>&2
cat >extstring.c <<'End of extstring.c'
/*
 * extstring.c: an extension of the standard C concept of character
 * strings to strings of n-byte (nonzero) values, terminated by a
 * marker of n zero bytes.
 */

#include "stdinc.h"
#include "getparam.h"

#define MAXLEN  1024				// input buffer length

//  ________________________________________________________________
//  getxstr: read extended string from input stream, return pointer.

void *getxstr(stream inpt, int nbyt)
{
    byte buf[MAXLEN], *bp;
    bool lpflg;
    int i, ch;

    bp = &buf[0];                               // set point into buffer
    do {                                        // loop reading data in
        lpflg = FALSE;                          // init loop flag
        for (i = 0; i < nbyt; i++) {            // loop over block of bytes
            ch = getc(inpt);                    // input next byte
            if (bp > &buf[MAXLEN-1])            // detect overflow error
                error("%s.getxstr: buffer overflow\n", getprog());
            *bp = ch != EOF ? ch : (int) NULL;  // map EOF to NULL
            if (*bp++ != (byte) NULL)           // got a byte of real data?
                lpflg = TRUE;                   // repeat for next block
        }
    } while (lpflg);                            // until a block of NULLs
    return (copxstr(&buf[0], nbyt));            // make copy and return it
}

//  ________________________________________________________________________
//  putxstr: write extended string to output stream, return TRUE on success.

bool putxstr(stream outp, void *xspt, int nbyt)
{
    byte *bp, c;
    int n;

    bp = (byte *) xspt;				// init pointer to string
    n = nbyt * xstrlen(xspt, nbyt);             // get length in bytes
    while (--n >= 0) {                          // loop writing out bytes
        c = *bp++;				// get byte to output
        putc(0377 & c, outp);			// and write eight bits out
        if (ferror(outp))			// did output call fail?
            return (FALSE);                     // then so did we
    }
    return (TRUE);                              // return sign of success
}

//  __________________________________________________________________________
//  copxstr: make copy of extended string in allocated memory, return pointer.

void *copxstr(void *xspt, int nbyt)
{
    byte *sp, *dp, *dest;
    int n;

    sp = (byte *) xspt;				// init pointer to string
    n = nbyt * xstrlen(xspt, nbyt);             // get length in bytes
    dp = dest = (byte *) allocate(n);           // allocate new storage
    while (--n >= 0)                            // loop over bytes
        *dp++ = *sp++;                          // copy each in turn
    return (dest);                              // return copy string
}

//  ____________________________________________________________________
//  xstrlen: count number of values (including null) in extended string.

int xstrlen(void *xspt, int nbyt)
{
    byte *bp;
    int nval, i;
    bool lpflg;

    bp = (byte *) xspt;				// init pointer to string
    nval = 0;                                   // init count of values
    do {                                        // loop over values
        nval++;                                 // count one more
        lpflg = FALSE;                          // init loop flag
        for (i = 0; i < nbyt; i++)              // loop over bytes
	  if (*bp++ != (byte) NULL)             // a byte of data?
                lpflg = TRUE;                   // set loop flag
    } while (lpflg);                            // until a NULL value
    return (nval);                              // return total count
}

//  ___________________________________________________________________
//  xstreq: determine if extended strings are equal, return TRUE if so.

bool xstreq(void *xp1, void *xp2, int nbyt)
{
    byte *bp1, *bp2;
    int n;

    bp1 = (byte *) xp1;				// init pointers to strings
    bp2 = (byte *) xp2;
    n = nbyt * xstrlen(xp1, nbyt);              // get length in bytes
    while (--n >= 0)                            // loop over bytes
        if (*bp1++ != *bp2++)                   // bytes not equal?
            return (FALSE);                     // then strs unequal
    return (TRUE);                              // indicate equality
}

#ifdef TESTBED

main(int argc, string argv[])
{
    int i;
    long lstr[32], *lcop;
    stream opt, ipt;

    for (i = 0; i < 32; i++)
        lstr[i] = (i < 21 ? 12345 + 512 * i : (int) NULL);
    printf("xstrlen(lstr, %d) == %d\n",
           sizeof(long), xstrlen(lstr, sizeof(long)));
    lcop = (long *) copxstr(lstr, sizeof(long));
    printf("xstrlen(lcop, %d) == %d\n",
           sizeof(long), xstrlen(lcop, sizeof(long)));
    printf("xstreq(lstr, lcop, %d) == %d\n",
           sizeof(long), xstreq(lstr, lcop, sizeof(long)));
    printf("changing *lcop\n");
    *lcop = -1;
    printf("xstreq(lstr, lcop, %d) == %d\n",
           sizeof(long), xstreq(lstr, lcop, sizeof(long)));
    opt = stropen("foobar.dat", "w!");
    printf("putxstr(opt, lstr, %d) == %d\n",
           sizeof(long), putxstr(opt, lstr, sizeof(long)));
    printf("putxstr(opt, lcop, %d) == %d\n",
           sizeof(long), putxstr(opt, lcop, sizeof(long)));
    fclose(opt);
    ipt = stropen("foobar.dat", "r");
    lcop = (long *) getxstr(ipt, sizeof(long));
    if (lcop == NULL)
        printf("getxstr(ipt, %d) failed\n", sizeof(long));
    printf("xstreq(lstr, lcop, %d) == %d\n",
           sizeof(long), xstreq(lstr, lcop, sizeof(long)));
}

#endif
End of extstring.c
echo filestruct.c 1>&2
cat >filestruct.c <<'End of filestruct.c'
/****************************************************************************/
/* filestruct.c: structured binary file package.                            */
/*       Version 1 by Josh Barnes & Lyman Hurd, IAS, 1987.                  */
/*       Version 2 by Josh Barnes, IAS, 1988.                               */
/*       Version 3 by Josh Barnes, IfA, April 1994.                         */
/****************************************************************************/
 
#include "stdinc.h"
#include "getparam.h"
#include <stdarg.h>
#include <assert.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "filestruct.h"

//  ______________________________________________
//  Magic numbers used to identify items in files.
 
#define ScalarMagic  ((011<<8) + 0222)          // for single items
#define PluralMagic  ((013<<8) + 0222)          // for plural items
 
//  __________________________________________
//  item: structure representing a data-token.
 
typedef struct {
    string type;                // specifies type of data; see .h file
    string tag;                 // name for data in external file
    int *dims;                  // int-string of dimensions, or NULL
    void *data;                 // actual data associated with item
    long datapos;               // where data begins in input stream
} item, *itemptr;    
 
//  _____________________________________________________
//  state: structure representing a structured I/O state.
 
typedef struct {
    stream str;                 // stream associated with state
    itemptr *buf;               // buffer of items read or written
    int maxbuf;                 // maximum number of items buffer can hold
    int itemcnt;                // number of items in buffer
    int context;                // next item to access during input
    bool canseek;               // true if seek operations are allowed
} state, *stateptr;
 
//  _________________________________________________________________________
//  Storage limits -- may be increased without rendering data files obsolete.
 
#define MaxVecDim   24          // maximum number of array dimensions
#define MaxStream   32          // maximum number of active streams
#define BufSizeInc  32          // initial item buffer size, and increment
#define MaxDataBuf 256          // read longer items on request, if we can

//  _______________________________
//  Local routines and definitions.
 
local stateptr findstate(stream);
local bool readset(stateptr);
local void bufitem(stateptr, itemptr);
local int finditem(stateptr, string);
local int findset(stateptr, int);
local int findtes(stateptr, int);
local void putitem(stateptr, itemptr, int *);
local itemptr getitem(stateptr);
local void getdata(itemptr, stateptr);
local void copydata(itemptr, int *, itemptr, stream);
local void copyint(itemptr, int *, itemptr, stream, int, int, int);
local void copybyte(itemptr, int *, itemptr, stream, int, int, int);
local void fillxbuf(byte **, int *, int *, int *, itemptr, stream, int);
local void inputdata(void *, itemptr, stream, int, int);
local bool checkdims(itemptr, itemptr);
local int convmode(itemptr, itemptr);
local int datalength(itemptr);
local int datacount(itemptr);
local itemptr makeitem(string, string, int *, void *);
local void freeitem(itemptr);
local void safewrite(stream, void *, int);
local void saferead(stream, void *, int);
local void safeseek(stream, long, int);
 
local string iofunc;			// for msgs from public routines
local int    iofcnt = 0;		// count calls between routines
 
#define set_iofunc(msg) if (iofcnt++ == 0) iofunc = (msg)
#define end_iofunc()    if (--iofcnt == 0) iofunc = NULL
 
//  __________________________________
//  External routines and definitions.
 
void free(void *);
 
#define cstrlen(x)  (xstrlen((x), sizeof(char)))
#define istrlen(x)  (xstrlen((x), sizeof(int)))
#define copycstr(x)  ((string) copxstr((x), sizeof(char)))
#define copyistr(x)  ((int *) copxstr((x), sizeof(int)))
#define getcstr(x)  ((string) getxstr((x), sizeof(char)))
#define getistr(x)  ((int *) getxstr((x), sizeof(int)))
#define istreq(x,y)  (xstreq((x), (y), sizeof(int)))

//
//  USER COPY FUNCTION
//
 
//  ____________________________________________________________
//  copy_item: recursively copy item from input to output.
//  An example of recursive file traversal and memory etiquette.

void copy_item(stream ostr, stream istr, string tag)
{
    string type, tag1;
    int *dims, dlen;
    byte *buf;

    set_iofunc("copy_item");
    if (! get_tag_ok(istr, tag))		// prevent obvious errors
	error("%s.%s: tag %s not found\n", getprog(), iofunc, tag);
    type = get_type(istr, tag);			// find out type of data
    if (! streq(type, SetType)) {		// a basic type or array?
	dims = get_dimensions(istr, tag);	// find out about shape
	dlen = get_length(istr, tag);		// and length in bytes
	buf = allocate(dlen);			// get space for a buffer
	get_data_sub(istr, tag, type, dims, (void *) buf, NULL);
						// read data from input
	put_data_sub(ostr, tag, type, dims, (void *) buf, NULL);
						// and write it to output
	if (dims != NULL)			// free dimension list
	    free(dims);
	free(buf);				// free temporary buffer
    } else {					// a set of other items?
	get_set(istr, tag);			// access set's contents
	put_set(ostr, tag);			// output set token
	while ((tag1 = next_item_tag(istr)) != NULL) {
						// loop over set contents
	    copy_item(ostr, istr, tag1);	// copying each item
	    free(tag1);				// free up name of item
	}
	get_tes(istr, tag);			// close access to set
	put_tes(ostr, tag);			// output termial symbol
    }
    free(type);					// free up type string
    end_iofunc();
}

//
//  USER OUTPUT FUNCTIONS
//
 
//  __________________________________________
//  put_set: begin named set in output stream.
 
void put_set(stream ostr, string tag)
{
    stateptr ostate;
    itemptr oitem;
 
    set_iofunc("put_set");                      // set name for messages
    ostate = findstate(ostr);                   // find corresponding state
    oitem = makeitem(SetType, tag, NULL, NULL); // create item with tag
    putitem(ostate, oitem, NULL);               // do actual output of set
    bufitem(ostate, oitem);                     // and add to state buffer
    end_iofunc();                               // end this activation
}  
 
//  __________________________________
//  put_tes: end set in output stream.
 
void put_tes(stream ostr, string tag)
{
    stateptr ostate;
    int setind, i;
    itemptr oitem;
 
    set_iofunc("put_tes");
    ostate = findstate(ostr);                   // find corresponding state
    if (ostate->itemcnt == 0)
        error("%s.%s: called before put_set\n", getprog(), iofunc);
    setind = findset(ostate, ostate->itemcnt);  // find opening set item
    if (! streq(ostate->buf[setind]->tag, tag))
        error("%s.%s: closing tag %s does not match opening tag %s\n",
              getprog(), iofunc, tag, ostate->buf[setind]->tag);
    oitem = makeitem(TesType, NULL, NULL, NULL);
    putitem(ostate, oitem, NULL);               // do actual output of tes
    bufitem(ostate, oitem);
    if (setind == 0) {                          // end of toplevel set?
        for (i = 0; i < ostate->itemcnt; i++)
            freeitem(ostate->buf[i]);           // done with these items
        ostate->itemcnt = 0;
    }
    end_iofunc();
}

//  ______________________________________________
//  put_string: write string to a structured file.
 
void put_string(stream ostr, string tag, string dat)
{
    set_iofunc("put_string");
    put_data(ostr, tag, CharType, dat, cstrlen(dat), 0);
    end_iofunc();
}
 
//  _________________________________________________
//  put_data: write data object to a structured file.
 
void put_data(stream ostr, string tag, string typ, void *dat, ...)
{
    va_list ap;
    int dims[MaxVecDim + 1], ndim;
 
    set_iofunc("put_data");
    va_start(ap, dat);                          // access argument list
    ndim = 0;
    do {                                        // loop reading dimensions
        if (ndim > MaxVecDim)
            error("%s.%s: item %s: too many dimensions\n",
		  getprog(), iofunc, tag);
        dims[ndim] = va_arg(ap, int);
    } while (dims[ndim++] != 0);                // until a zero comes up
    va_end(ap);
    put_data_sub(ostr, tag, typ, ndim > 1 ? dims : NULL, dat, NULL);
                                                // pass dims, if any
    end_iofunc();
}

//  _______________________________________________________________
//  put_data_masked: write masked data object to a structured file.
 
void put_data_masked(stream ostr, string tag, string typ, void *dat, ...)
{
    va_list ap;
    int dims[MaxVecDim + 1], ndim, *mask;
 
    set_iofunc("put_data_masked");
    va_start(ap, dat);                          // access argument list
    ndim = 0;
    do {                                        // loop getting dimensions
        if (ndim > MaxVecDim)
            error("%s.%s: item %s: too many dimensions\n",
		  getprog(), iofunc, tag);
        dims[ndim] = va_arg(ap, int);
    } while (dims[ndim++] != 0);                // until a zero comes up
    mask = va_arg(ap, int *);                   // get mask following dims
    va_end(ap);
    put_data_sub(ostr, tag, typ, ndim > 1 ? dims : NULL, dat, mask);
    end_iofunc();
}
 
//  __________________________________________________________________________
//  put_data_sub: routine to handle output operation, using arguments gathered
//  by put_data and put_data_masked, or supplied directly by the user.

 
void put_data_sub(stream ostr, string tag, string type,
                  int *dims, void *data, int *mask)
{
    stateptr ostate;
    itemptr oitem;
 
    set_iofunc("put_data_sub");
    ostate = findstate(ostr);                   // find corresponding state
    oitem = makeitem(type, tag, dims, data);
    putitem(ostate, oitem, mask);               // do actual data output
    bufitem(ostate, oitem);
    if (ostate->itemcnt == 1) {                 // free toplevel items
        freeitem(oitem);
        ostate->itemcnt = 0;
    }
    end_iofunc();
}

//
//  USER INPUT FUNCTIONS
//
 
//  _____________________________________________________
//  get_set: switch context to named set in input stream.
 
void get_set(stream istr, string tag)
{
    stateptr istate;
    int setind;
 
    set_iofunc("get_set");
    istate = findstate(istr);                   // find corresponding state
    if (istate->itemcnt == 0 && ! readset(istate))
        error("%s.%s: at end of file\n", getprog(), iofunc);
    setind = finditem(istate, tag);             // get index of named set
    if (setind == -1)
        error("%s.%s: item %s not found\n", getprog(), iofunc, tag);
    if (! streq(istate->buf[setind]->type, SetType))
        error("%s.%s: %s not a set\n", getprog(), iofunc, tag);
    istate->context = setind + 1;               // point to 1st item in set
    end_iofunc();
}
 
//  _____________________________________________________
//  get_tes: switch context to set enclosing current one.
 
void get_tes(stream istr, string tag)
{
    stateptr istate;
    int setind, tesind, i;
 
    set_iofunc("get_tes");
    istate = findstate(istr);                   // find corresponding state
    if (istate->context == 0)
        error("%s.%s: called before get_set\n", getprog(), iofunc);
    setind = findset(istate, istate->context);  // find start of this set
    if (! streq(istate->buf[setind]->tag, tag))
        error("%s.%s: closing tag %s does not match opening tag %s\n",
              getprog(), iofunc, tag, istate->buf[setind]->tag);
    if (setind > 0) {                           // at end of subset?
        tesind = findtes(istate, istate->context);
        istate->context = tesind + 1;           // point past closing tes
    } else {                                    // at end of toplevel set?
        for (i = 0; i < istate->itemcnt; i++) {
            if (istate->buf[i]->data != NULL)   // free data and item
                free(istate->buf[i]->data);
            freeitem(istate->buf[i]);
        }
        istate->context = istate->itemcnt = 0;
    }
    end_iofunc();
}

//  _________________________________________________
//  get_string: read a string from a structured file.
 
string get_string(stream istr, string tag)
{
    int dlen;
    string dat;
 
    set_iofunc("get_string");
    dlen = get_length(istr, tag);
    dat = allocate(dlen + 1);                   // add 1 byte for null
    get_data(istr, tag, CharType, dat, dlen, 0);
    dat[dlen] = (char) NULL;                    // set terminating byte
    end_iofunc();
    return (dat);
}
 
//  __________________________________________________
//  get_data: read data object from a structured file.
 
void get_data(stream istr, string tag, string typ, void *dat, ...)
{
    va_list ap;
    int dims[MaxVecDim + 1], ndim;
 
    set_iofunc("get_data");
    va_start(ap, dat);                          // access argument list
    ndim = 0;
    do {                                        // loop reading dimensions
        if (ndim > MaxVecDim)
            error("%s.%s: too many dimensions; item %s\n",
		  getprog(), iofunc, tag);
        dims[ndim] = va_arg(ap, int);
    } while (dims[ndim++] != 0);                // until a zero comes up
    va_end(ap);
    get_data_sub(istr, tag, typ, ndim > 1 ? dims : NULL, dat, NULL);
                                                // pass dims, if any
    end_iofunc();
}

//  _________________________________________________________
//  get_data_masked: read data object from a structured file.
 
void get_data_masked(stream istr, string tag, string typ, void *dat, ...)
{
    va_list ap;
    int dims[MaxVecDim + 1], ndim, *mask;
 
    set_iofunc("get_data_masked");
    va_start(ap, dat);                          // access argument list
    ndim = 0;
    do {                                        // loop getting dimensions
        if (ndim > MaxVecDim)
            error("%s.%s: too many dimensions; item %s\n",
		  getprog(), iofunc, tag);
        dims[ndim] = va_arg(ap, int);
    } while (dims[ndim++] != 0);                // until a zero comes up
    mask = va_arg(ap, int *);                   // get mask following dims
    va_end(ap);
    get_data_sub(istr, tag, typ, ndim > 1 ? dims : NULL, dat, mask);
    end_iofunc();
}
 
//  _________________________________________________________________________
//  get_data_sub: routine to handle input operation, using arguments gathered
//  by get_data and get_data_masked, or supplied directly by the user.
 
void get_data_sub(stream istr, string tag, string type,
                  int *dims, void *data, int *mask)
{
    stateptr istate;
    int indx;
    itemptr ditem;
 
    set_iofunc("get_data_sub");
    istate = findstate(istr);                   // find corresponding state
    if (istate->itemcnt == 0 && ! readset(istate))
        error("%s.%s: at end of file\n", getprog(), iofunc);
    indx = finditem(istate, tag);               // get index of named item
    if (indx == -1)
        error("%s.%s: %s not found\n", getprog(), iofunc, tag);
    ditem = makeitem(type, tag, dims, data);    // make destination item
    copydata(ditem, mask, istate->buf[indx], istr);
                                                // transfer actual data
    freeitem(ditem);
    if (istate->context > 0)
        istate->context = indx + 1;             // advance context in set
    else {
        free(istate->buf[0]->data);             // free toplevel item
        freeitem(istate->buf[0]);
        istate->context = istate->itemcnt = 0;
    }
    end_iofunc();
}

//  _____________________________________________________________________
//  get_tag_ok: return TRUE if tag exists in current context, else FALSE.
 
bool get_tag_ok(stream istr, string tag)
{
    stateptr istate;
    int indx;
 
    set_iofunc("get_tag_ok");
    istate = findstate(istr);                   // find corresponding state
    indx = (istate->itemcnt == 0 && ! readset(istate) ?
              -1 : finditem(istate, tag));      // scan context for tag
    end_iofunc();
    return (indx != -1);
}
 
//  ________________________________________
//  get_type: return type of specified item.
 
string get_type(stream istr, string tag)
{
    stateptr istate;
    int indx;
 
    set_iofunc("get_type");
    istate = findstate(istr);
    if (istate->itemcnt == 0 && ! readset(istate))
        error("%s.%s: at end of file\n", getprog(), iofunc);
    indx = finditem(istate, tag);
    if (indx == -1)
        error("%s.%s: %s not found\n", getprog(), iofunc, tag);
    end_iofunc();
    return (copycstr(istate->buf[indx]->type)); // return copy of item type
}

//  ___________________________________________________________
//  get_dimensions: return dimension list of specified item, or
//  NULL if the item is a scalar.
 
int *get_dimensions(stream istr, string tag)
{
    stateptr istate;
    int indx;
 
    set_iofunc("get_dimensions");
    istate = findstate(istr);
    if (istate->itemcnt == 0 && ! readset(istate))
        error("%s.%s: at end of file\n", getprog(), iofunc);
    indx = finditem(istate, tag);
    if (indx == -1)
        error("%s.%s: %s not found\n", getprog(), iofunc, tag);
    end_iofunc();
    return (istate->buf[indx]->dims != NULL ?
              copyistr(istate->buf[indx]->dims) : NULL);
                                                // return copy of item dims
}
 
//  _____________________________________________________________
//  get_length: return length in bytes of data of specified item.
 
int get_length(stream istr, string tag)
{
    stateptr istate;
    int indx, dlen;
 
    set_iofunc("get_length");
    istate = findstate(istr);
    if (istate->itemcnt == 0 && ! readset(istate))
        error("%s.%s: at end of file\n", getprog(), iofunc);
    indx = finditem(istate, tag);
    if (indx == -1)
        error("%s.%s: %s not found\n", getprog(), iofunc, tag);
    dlen = datalength(istate->buf[indx]);
    end_iofunc();
    return (dlen);
}

//  __________________________________________________
//  next_item_tag: return tag of next item in context,
//  or NULL at end of set or file.
 
string next_item_tag(stream istr)
{
    stateptr istate;
    string tag;
 
    set_iofunc("next_item_tag");
    istate = findstate(istr);                   // find corresponding state
    if (istate->itemcnt == 0 && ! readset(istate))
        tag = NULL;
    else
        tag = istate->buf[istate->context]->tag;
    end_iofunc();
    return (tag != NULL ? copycstr(tag) : NULL);
                                                // return copy of tag
}
 
//  _________________________________________________________________
//  skip_item: advance context within set, or flush item at toplevel.
//  Returns TRUE on success, FALSE on end of file.
 
bool skip_item(stream istr)
{
    stateptr istate;
    int i;
 
    set_iofunc("skip_item");
    istate = findstate(istr);                   // find corresponding state
    if (istate->itemcnt == 0 && ! readset(istate)) {
        end_iofunc();
        return (FALSE);
    }
    if (istate->context > 0) {                  // skip item within set
        if (streq(istate->buf[istate->context]->type, TesType))
            istate->context = findset(istate, istate->context);
        else if (streq(istate->buf[istate->context]->type, SetType))
            istate->context = findtes(istate, istate->context + 1);
        istate->context++;
    } else {                                    // skip item at toplevel
        for (i = 0; i < istate->itemcnt; i++) {
            if (istate->buf[i]->data != NULL)   // free data and item
                free(istate->buf[i]->data);
            freeitem(istate->buf[i]);
        }
        istate->context = istate->itemcnt = 0;
    }
    end_iofunc();
    return (TRUE);
}

//
//  ASSORTED CONTROL FUNCTIONS
//
 
//  ____________________________________________
//  fs_options: select input conversion options.
 
local int conformdata = WarnEach;	// warn about data conformence	
local int convertdata = WarnEach;	// warn about data conversion	
 
void fs_options(int cfd, int cnd)
{
    if (cfd != NoChange)			// change data-conformance
        conformdata = cfd;
    if (cnd != NoChange)			// change type-conversion
        convertdata = cnd;
}
 
//  __________________________________________________________
//  strclose: close stream and remove from stream state table.
 
void strclose(stream str)
{
    stateptr iostate;
 
    fclose(str);
    iostate = findstate(str);   
    iostate->str = NULL;
    free(iostate->buf);
}    

//
//  LOW LEVEL ROUTINES
//
 
//  __________________________________________________________________
//  findstate: find stream in state table, and return state structure.
 
local state strtab[MaxStream] = { NULL, };
 
local stateptr findstate(stream str)
{
    int i;
    struct stat statbuf;
 
    for (i = 0; i < MaxStream; i++)
        if (strtab[i].str == str)
            return (&strtab[i]);
    for (i = 0; i < MaxStream && strtab[i].str != NULL; i++) ;
    if (i == MaxStream)
        error("%s.%s: no room in stream table\n", getprog(), iofunc);
    strtab[i].str = str;
    strtab[i].buf = (itemptr *) allocate(sizeof(itemptr) * BufSizeInc);
    strtab[i].maxbuf = BufSizeInc;
    strtab[i].itemcnt = strtab[i].context = 0;
    if (fstat(fileno(str), &statbuf) == -1)
        error("%s.%s: can't get status of stream %d\n",
	      getprog(), iofunc, fileno(str));
    strtab[i].canseek = (statbuf.st_mode & S_IFMT) == S_IFREG;
    return (&strtab[i]);
}
 
//  ____________________________________
//  bufitem: store item in state buffer.
 
local void bufitem(stateptr iostate, itemptr newitem)
{
    int newmax, i;
    itemptr *newbuf;
 
    if (iostate->itemcnt == iostate->maxbuf) {  // need to enlarge buffer?
        newmax = iostate->maxbuf + BufSizeInc;  // enlarge by BufSizeInc
        if ((newmax & iostate->maxbuf) == 0)
            eprintf("[%s.%s: enlarging item buffer]\n", getprog(), iofunc);
        newbuf = (itemptr *) allocate(sizeof(itemptr) * newmax);
        for (i = 0; i < iostate->itemcnt; i++)  // copy old one over
            newbuf[i] = iostate->buf[i];
        free(iostate->buf);
        iostate->buf = newbuf;                  // install new buffer
        iostate->maxbuf = newmax;
    }
    iostate->buf[iostate->itemcnt++] = newitem; // insert item in buffer
}

//  ______________________________________________________________________
//  finditem: scan current context for named item; return index in buffer,
//  or -1 if not found.
 
local int finditem(stateptr iostate, string tag)
{
    int level, i;
 
    level = 0;
    for (i = iostate->context; i < iostate->itemcnt && level >= 0; i++) {
        if (level == 0 && iostate->buf[i]->tag != NULL &&
              streq(iostate->buf[i]->tag, tag))
            return (i);
        if (streq(iostate->buf[i]->type, SetType))
            level++;
        else if (streq(iostate->buf[i]->type, TesType))
            level--;
    }
    level = 0;
    for (i = iostate->context - 1; i >= 0 && level >= 0; i--) {
        if (streq(iostate->buf[i]->type, TesType))
            level++;
        else if (streq(iostate->buf[i]->type, SetType))
            level--;
        if (level == 0 && iostate->buf[i]->tag != NULL &&
              streq(iostate->buf[i]->tag, tag))
            return (i);
    }
    return (-1);
}
 
//  ________________________________________________________
//  findset: scan back through buffer to find enclosing set.
 
local int findset(stateptr iostate, int cont)
{
    int level, i;
 
    level = 0;
    for (i = cont - 1; i >= 0; i--) {
        if (streq(iostate->buf[i]->type, TesType))
            level++;
        else if (streq(iostate->buf[i]->type, SetType))
            level--;
        if (level < 0)
            return (i);
    }
    error("%s.%s: can't find set\n", getprog(), iofunc);
    return (0);					// keep compiler happy...
}

//  ___________________________________________________________
//  findtes: scan forward through buffer to find enclosing tes.
 
local int findtes(stateptr iostate, int cont)
{
    int level, i;
 
    level = 0;
    for (i = cont; i < iostate->itemcnt; i++) {
        if (streq(iostate->buf[i]->type, SetType))
            level++;
        else if (streq(iostate->buf[i]->type, TesType))
            level--;
        if (level < 0)
            return (i);
    }
    error("%s.%s: can't find tes\n", getprog(), iofunc);
    return (0);					// keep compiler happy...
}
 
//  ________________________________________________________
//  putitem: write header and data of item to output stream.
 
local void putitem(stateptr ostate, itemptr oitem, int *mask)
{
    short magic;
    int obyte, *mp, n;
    byte *op;
 
    magic = (oitem->dims != NULL ? PluralMagic : ScalarMagic);
    safewrite(ostate->str, &magic, sizeof(short));
    safewrite(ostate->str, oitem->type, cstrlen(oitem->type));
    if (oitem->tag != NULL)
        safewrite(ostate->str, oitem->tag, cstrlen(oitem->tag));
    if (oitem->dims != NULL)
        safewrite(ostate->str, oitem->dims,
		  sizeof(int) * istrlen(oitem->dims));
    if (oitem->data != NULL) {			// have data to output?
        if (mask == NULL)			// if possible, just write
            safewrite(ostate->str, oitem->data, datalength(oitem));
        else {					// output with masking
	    obyte = datalength(oitem);		// count bytes to output
            op = (byte *) oitem->data;		// start at front of data
	    mp = mask;				// and at front of mask
	    while (obyte > 0) {			// loop while bytes remain
		n = *mp++;			// get output/skip count
		if (n < 0)			// should skip some bytes?
		    op -= n;			// just advance pointer
		else {				// should output some bytes
		    safewrite(ostate->str, op, n);
		    op += n;			// advance output pointer
		    obyte -= n;			// count bytes done
		}
		mp = (*mp == 0 ? mask : mp);	// renew mask pointer
	    }
	    if (obyte < 0)			// this should not happen
		error("%s.%s: item %s: incommensurate mask\n",
		      getprog(), iofunc, oitem->tag);
	}
    }
}

//  _________________________________________________________
//  readset: read an item or entire set into an empty buffer.
 
local bool readset(stateptr istate)
{
    int level;
    itemptr iitem;
 
    assert(istate->itemcnt == 0);
    level = 0;
    do {
        iitem = getitem(istate);
        if (iitem == NULL && level == 0)
            return (FALSE);
        if (iitem == NULL && level > 0)
            error("%s.%s: EOF within set at level %d\n",
		  getprog(), iofunc, level);
        bufitem(istate, iitem);
        if (streq(iitem->type, SetType))
            level++;
        else if (streq(iitem->type, TesType))
            level--;
    } while (level > 0);
    istate->context = 0;
    return (TRUE);
}       

//  __________________________________________________________________
//  getitem: read item from input, and return pointer, or NULL on EOF.
 
local itemptr getitem(stateptr istate)
{
    short magic, cigam;
    string type, tag;
    int *dims, *ip;
    itemptr iitem;
 
    if (fread(&magic, sizeof(short), 1, istate->str) != 1)
        return (NULL);				// nothing more to read	
    cigam = ((magic & 0xff) << 8) | ((magic & 0xff00) >> 8);
						// form swapped version
    if (magic != ScalarMagic && cigam != ScalarMagic &&
	magic != PluralMagic && cigam != PluralMagic)
        error("%s.%s: bad magic number %04x\n",
	      getprog(), iofunc, 0xffff & magic);
    if (cigam == ScalarMagic || cigam == PluralMagic)
	eprintf("[%s.%s: WARNING: reading swapped data]\n",
		getprog(), iofunc);
    type = getcstr(istate->str);		// read item components	
    tag = (streq(type, TesType) ? NULL : getcstr(istate->str));
    dims = (magic == PluralMagic || cigam == PluralMagic ?
	    getistr(istate->str) : NULL);
    if (cigam == PluralMagic)
      for (ip = dims; *ip != (int) NULL; ip++)
	    *ip = ((*ip & 0xff) << 24) | ((*ip & 0xff00) << 8) |
	          ((*ip & 0xff0000) >> 8) | ((*ip & 0xff000000) >> 24);
    iitem = makeitem(type, tag, dims, NULL);	// construct actual item
    if (! streq(type, SetType) && ! streq(type, TesType))
        getdata(iitem, istate);			// read (or skip) item data
    free(type);					// free temporary storage
    if (tag != NULL)
        free(tag);
    if (dims != NULL)
        free(dims);
    return (iitem);
}
 
//  _____________________________________________________________
//  getdata: read data for item, or record place in input stream.
 
local void getdata(itemptr iitem, stateptr istate)
{
    int nb;
 
    nb = datalength(iitem);
    if (nb > MaxDataBuf && istate->canseek) {	// skip data input for now?
        iitem->data = NULL;
        iitem->datapos = ftell(istate->str);	// remember this place	
        safeseek(istate->str, nb, SEEK_CUR);	// and seek past data
    } else {
        iitem->datapos = 0;
        iitem->data = allocate(nb);		// allocate data buffer	
        saferead(istate->str, iitem->data, nb);	// actually read the data
    }
}

//  _____________________________________________________________
//  copydata: transfer data from source item to destination item.
//  The source data may reside within memory, or in a disk file.
//  Interconversion of float and double takes place if needed.
//  Multidimensional arrays may be truncated/collapsed to vectors.
//  If a mask string is given, the destination bytes are masked.
 
#define NoWayBaby     0			// types cannot be interconverted
#define DirectCopy    1			// no interconversion is needed	
#define Float2Double  2			// source is float, dest is double
#define Double2Float  3			// source is doubel, dest is float
 
local void copydata(itemptr ditem, int *mask, itemptr sitem, stream sstr)
{
    int conv, dbyte, sbyte, defmask[2];
    long currpos;
 
    conv = convmode(ditem, sitem);		// set data conversion	
    if (conv == NoWayBaby)
	error("%s.%s: item %s: cannot convert type\n",
	      getprog(), iofunc, ditem->tag);
    if (! checkdims(ditem, sitem))              // check data congruency
	error("%s.%s: item %s: incongruent dimensions\n",
	      getprog(), iofunc, ditem->tag);
    if (sitem->data == NULL) {			// data not yet in core?
        currpos = ftell(sstr);
        safeseek(sstr, sitem->datapos, SEEK_SET);
    }
    if (conv == DirectCopy && mask == NULL) {   // if possible, just copy
        inputdata(ditem->data, sitem, sstr, 0, datalength(ditem));
    } else {                                    // transfer with mapping
        dbyte = datalength(ditem);		// count bytes to transfer
        sbyte = datalength(sitem);
	if (mask == NULL) {			// no masking required?
	    mask = defmask;			// setup a default mask
	    defmask[0] = dbyte;			// covering entire dest'n
	    defmask[1] = 0;
	}
	if (type_length(ditem->type) % sizeof(int) == 0)
	    copyint(ditem, mask, sitem, sstr, conv, dbyte, sbyte);
	else
	    copybyte(ditem, mask, sitem, sstr, conv, dbyte, sbyte);
    }
    if (sitem->data == NULL)			// data just read in?
        safeseek(sstr, currpos, SEEK_SET);	// then restore stream pos
}

local void copyint(itemptr ditem, int *mask, itemptr sitem, stream sstr,
		   int conv, int dbyte, int sbyte)
{
    int sskip, xbyte, *mp, ncopy, n, *dp, *xp, *dstop;

    sskip = xbyte = 0;                     	// zero offset and buffer
    dp = (int *) ditem->data;              	// start at front of data
    mp = mask;					// and at front of mask
    while (dbyte > 0) {				// loop while bytes remain
	if (*mp < 0)				// should skip some bytes?
	    dp -= *mp++ / sizeof(int);		// just advance pointer
	else {					// should copy some bytes
	    ncopy = *mp++;			// set number to copy
	    dbyte -= ncopy;			// count that many done	
	    if (dbyte < 0)			// this should not happen
		error("%s.%s: item %s: incommensurate mask\n",
		      getprog(), iofunc, ditem->tag);
	    do {				// loop filling xfer buffer
		if (xbyte == 0)			// is the buffer empty?
		    fillxbuf((byte **) &xp, &xbyte, &sskip, &sbyte,
			     sitem, sstr, conv);
		n = MIN(ncopy, xbyte);		// find max ready to copy
		dstop = dp + n / sizeof(int);	// fix stopping point
		while (dp < dstop)		// loop copying ints...
		    *dp++ = *xp++;		// one by one they go
		xbyte -= n;			// count bytes in buffer
		ncopy -= n;			// and bytes still to copy
	    } while (ncopy > 0);		// loop back if more to do
	}
	mp = (*mp == 0 ? mask : mp);		// renew mask pointer
    }
}

local void copybyte(itemptr ditem, int *mask, itemptr sitem, stream sstr,
		    int conv, int dbyte, int sbyte)
{
    int sskip, xbyte, *mp, ncopy, n;
    byte *dp, *xp, *dstop;

    sskip = xbyte = 0;                     	// zero offset and buffer
    dp = (byte *) ditem->data;              	// start at front of data
    mp = mask;					// and at front of mask
    while (dbyte > 0) {				// loop while bytes remain
	if (*mp < 0)				// should skip some bytes?
	    dp -= *mp++;			// just advance pointer
	else {					// should copy some bytes
	    ncopy = *mp++;			// set number to copy
	    dbyte -= ncopy;			// count that many done
	    if (dbyte < 0)			// this should not happen
		error("%s.%s: item %s: incommensurate mask\n",
		      getprog(), iofunc, ditem->tag);
	    do {				// loop filling xfer buffer
		if (xbyte == 0)			// is the buffer empty?
		    fillxbuf(&xp, &xbyte, &sskip, &sbyte, sitem, sstr, conv);
		n = MIN(ncopy, xbyte);		// find max ready to copy
		dstop = dp + n;			// fix stopping point
		while (dp < dstop)		// loop copying bytes...
		    *dp++ = *xp++;		// one at a time (sigh)
		xbyte -= n;			// count bytes in buffer
		ncopy -= n;			// and bytes still to copy
	    } while (ncopy > 0);		// loop back if more to do
	}
	mp = (*mp == 0 ? mask : mp);		// renew mask pointer
    }
}

//  _______________________________________________________________________
//  fillxbuf: fill transfer buffer, performing float <-> double conversion.
 
local void fillxbuf(byte **xpp, int *xbytep, int *sskipp, int *sbytep,
                    itemptr sitem, stream sstr, int conv)
{
    static byte xbuf[MaxDataBuf];
    static float fbuf[MaxDataBuf / sizeof(float)];
    static double dbuf[MaxDataBuf / sizeof(float)];
    int scount, n;
 
    switch (conv) {
      case DirectCopy:                          // no conversion required
        scount = MIN(*sbytep, sizeof(xbuf));
        inputdata(xbuf, sitem, sstr, *sskipp, scount);
        *xpp = xbuf;
        *xbytep = scount;                   
        break;
      case Float2Double:                        // convert float -> double
        scount = MIN(*sbytep, sizeof(fbuf));
        inputdata(fbuf, sitem, sstr, *sskipp, scount);
        n = scount / sizeof(float);             // number of floats read
        while (--n >= 0)
           dbuf[n] = fbuf[n];                   // copy and convert them
        *xpp = (byte *) dbuf;
        *xbytep = (scount * sizeof(double)) / sizeof(float);
        break;
      case Double2Float:                        // convert double -> float
        scount = MIN(*sbytep, sizeof(dbuf));
        inputdata(dbuf, sitem, sstr, *sskipp, scount);
        n = scount / sizeof(double);
        while (--n >= 0)
            fbuf[n] = dbuf[n];
        *xpp = (byte *) fbuf;
        *xbytep = (scount * sizeof(float)) / sizeof(double);
        break;
      default:
        error("%s.%s: bad conversion\n", getprog(), iofunc);
    }
    *sskipp += scount;
    *sbytep -= scount;
}

//  _________________________________________________________________
//  inputdata: transfer scount bytes from source item to destination.
 
local void inputdata(void *data, itemptr sitem, stream sstr,
                     int sskip, int scount)
{
    byte *dp = (byte *) data, *sp = (byte *) sitem->data + sskip;
 
    if (sitem->data != NULL)
        while (--scount >= 0)
            *dp++ = *sp++;
    else
        saferead(sstr, data, scount);
}

//  ___________________________________________________
//  convmode: determine conversion mode for data input.
 
local int convmode(itemptr ditem, itemptr sitem)
{
    string dtype = ditem->type, stype = sitem->type;
 
    if (streq(stype, dtype))			// types match exactly?
        return (DirectCopy);
    if (convertdata != NotAllow) {		// data coercion allowed?
        if (streq(stype, FloatType) && streq(dtype, DoubleType)) {
	    if (convertdata != SilentOK)
        	eprintf("[%s.%s: converting %s to double]\n",
			getprog(), iofunc, ditem->tag);
	    if (convertdata == WarnOnce)
	        convertdata = SilentOK;
            return (Float2Double);
        }
        if (streq(stype, DoubleType) && streq(dtype, FloatType)) {
	    if (convertdata != SilentOK)
	        eprintf("[%s.%s: converting %s to float]\n",
			getprog(), iofunc, ditem->tag);
	    if (convertdata == WarnOnce)
	        convertdata = SilentOK;
            return (Double2Float);
	}
    }
    return (NoWayBaby);				// no way to coerce type
}

//  ________________________________________________________________
//  checkdims: return TRUE if item dimensions can be made congruent.
 
local bool checkdims(itemptr ditem, itemptr sitem)
{
    int *ddims = ditem->dims, *sdims = sitem->dims;
 
    if (ddims == NULL && sdims == NULL)
        return (TRUE);				// both items are scalars
    if (ddims != NULL && sdims != NULL && istreq(ddims, sdims))
        return (TRUE);				// dimensions match exactly
    if (conformdata != NotAllow && ddims != NULL && istrlen(ddims) == 2 &&
	  ddims[0] <= datacount(sitem)) {	// can conform input data?
	if (conformdata != SilentOK)
	    eprintf("[%s.%s: WARNING: conforming item %s]\n",
		    getprog(), iofunc, ditem->tag);
	if (conformdata == WarnOnce)
	    conformdata = SilentOK;
        return (TRUE);				// allow data conformance
    }
    return (FALSE);				// data are not congruent
}

//  ________________________________________________________________________
//  datalength, datacount: compute length in bytes or elements of item data.
 
local int datalength(itemptr ioitem)
{
    return (datacount(ioitem) * type_length(ioitem->type));
}
 
local int datacount(itemptr ioitem)
{
    int nelt, *ip;
 
    nelt = 1;
    if (ioitem->dims != NULL)
      for (ip = ioitem->dims; *ip != (int) NULL; ip++)
            nelt *= *ip;
    return (nelt);
}

//  _____________________________________________________________________
//  makeitem: allocate an item, and initialize fields.  The type, tag and
//  dimension arguments are copied; the data is not, since it may be big.
 
local itemptr makeitem(string type, string tag, int *dims, void *data)
{
    itemptr ioitem;
 
    ioitem = (itemptr) allocate(sizeof(item));
    ioitem->type = copycstr(type);
    ioitem->tag = (tag != NULL ? copycstr(tag) : NULL);
    ioitem->dims = (dims != NULL ? copyistr(dims) : NULL);
    ioitem->data = data;
    ioitem->datapos = 0;
    return (ioitem);
}
 
//  ______________________________________________________________________
//  freeitem: deallocate an item, including all fields copied by makeitem.
 
local void freeitem(itemptr ioitem)
{
    free(ioitem->type);
    if (ioitem->tag != NULL)
        free(ioitem->tag);
    if (ioitem->dims != NULL)
        free(ioitem->dims);
    free(ioitem);
}
 
//  ___________________________________________________________________
//  safewrite, saferead, safeseek: I/O operations, with error checking.
 
local void safewrite(stream str, void *data, int len)
{
    if (fwrite(data, sizeof(byte), len, str) != len)
        error("%s.%s: write failed (%d bytes)\n", getprog(), iofunc, len);
}
 
local void saferead(stream str, void *data, int len)
{
    if (fread(data, sizeof(byte), len, str) != len)
        error("%s.%s: read failed (%d bytes)\n", getprog(), iofunc, len);
}
 
local void safeseek(stream str, long offset, int key)
{
    if (fseek(str, offset, key) == -1)
        error("%s.%s: fseek failed (%lx bytes)\n", getprog(), iofunc, offset);
}
End of filestruct.c
echo filestruct_test.c 1>&2
cat >filestruct_test.c <<'End of filestruct_test.c'
/*
 * FILETEST: test filestruct package.
 */

#include "stdinc.h"
#include "getparam.h"
#include "filestruct.h"

string defv[] = {
    "out=foo.dat",
    "in=foo.dat",
    NULL,
};

string headline = "Mumbo Jumbo";
int nobj = 2;
real mass[2] = { 1.0, 2.0 };
real phase[2][2][3] = {
    { {  0.10,  -0.20,  0.30 }, { -3.0,  2.0, -1.0 } },
    { { -0.05,   0.10, -0.15 }, {  1.5, -1.0,  0.5 } }
};

double dmass[2];

int intvals[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };

int mask[3] = { 4, -4, 0 };

void main(int argc, string argv[])
{
    stream instr, outstr;
    string tag;

    initparam(argv, defv);
    outstr = stropen(getparam("out"), "w!");
    put_set(outstr, "SnapShot");
    put_string(outstr, "Headline", headline);
    put_set(outstr, "Parameters");
    put_data(outstr, "Nobj", IntType, &nobj, 0);
    put_tes(outstr, "Parameters");
    put_set(outstr, "Particles");
    put_data(outstr, "PhaseSpace", RealType, phase, nobj, 2, 3, 0);
    put_data(outstr, "Mass", RealType, mass, nobj, 0);
    put_tes(outstr, "Particles");
    put_string(outstr, "String", "Hello World!");
    put_data(outstr, "IntVals", IntType, intvals, 12, 0);
    put_data_masked(outstr, "MaskedIntVals", IntType, intvals, 6, 0, mask);
    put_tes(outstr, "SnapShot");
    strclose(outstr);
    instr = stropen(getparam("in"), "r");
    while (get_tag_ok(instr, "History"))
	skip_item(instr);
    while (get_tag_ok(instr, "SnapShot")) {	// loop reading snapshots
	get_set(instr, "SnapShot");
	printf("  Tags in SnapShot:");
	while ((tag = next_item_tag(instr)) != NULL) {
	    printf(" %s", tag);
	    skip_item(instr);
	}
	printf("\n");
	if (get_tag_ok(instr, "String"))
	    printf("  String: %s\n", get_string(instr, "String"));
	get_set(instr, "Parameters");		// assume params exist
	get_data(instr, "Nobj", IntType, &nobj, 0);
	printf("    Nobj: %d\n", nobj);
	nobj = MIN(nobj, 2);
	get_tes(instr, "Parameters");
	if (get_tag_ok(instr, "Particles")) {	// if particles given
	    get_set(instr, "Particles");
	    if (get_tag_ok(instr, "Mass")) {
		printf("    Mass: type %s, length 0%o\n",
		       get_type(instr, "Mass"), get_length(instr, "Mass"));
		get_data(instr, "Mass", RealType, mass, nobj, 0);
		printf("    Mass: %f %f ...\n", mass[0], mass[1]);
		get_data(instr, "Mass", DoubleType, dmass, nobj, 0);
		printf("    Mass: %f %f ...\n", dmass[0], dmass[1]);
	    }
	    get_data(instr, "PhaseSpace", RealType, phase, nobj, 2, 3, 0);
	    printf("    Phase: %f %f %f ...\n",
		   phase[0][0][0], phase[0][0][1], phase[0][0][2]);
	    get_tes(instr, "Particles");
	}
	get_tes(instr, "SnapShot");
    }
    strclose(instr);
}
End of filestruct_test.c
echo getparam.c 1>&2
cat >getparam.c <<'End of getparam.c'
/*
 * getparam.c: command-line processing functions.
 */

#include "stdinc.h"
#include "getparam.h"
#include <string.h>

//  Local routines and definitions.

//  ______________________________________________
//  param: structure encoding parameter and value.

typedef struct {
  string name;					// name of parameter
  string value;					// value of parameter
  string comment;				// documentation string
  int flags;					// for various options
} param;

local int countdefaults(string *);		// number of defaults
local void setprogram(param *, string);		// set 0th parameter
local void copydefaults(param *, string *);	// set default parameters
local void checkhelp(param *, string);		// help processing
local void printparam(string, string, bool);	// print param and comment
local void setarguments(param *, string *);	// set command parameters
local void checkusage(param *);			// usage processing
local void savehistory(param *);		// history interface
local param *findparam(string, param *);	// look up parameter
local string parname(string);			// extract param name
local string parvalue(string);			// extract param value

local param *paramvec = NULL;			// vector of parameters

local string progname;				// program name, for errors

#define BUFLEN  1025				// storage for comments

//  _________________________________________________________________
//  initparam: initalize parameter lists and handle special requests.

void initparam(string *argv, string *defv)
{
  int nparam;
  param *pvec;

  progname = argv[0];				// initialize program name
  nparam = 1 + countdefaults(defv);		// include argv0 in count
  pvec = (param *) allocate(sizeof(param) * (nparam + 1));
  setprogram(pvec, argv[0]);			// install 0th argument
  copydefaults(pvec, defv);			// set up default values
  if (argv[1] != NULL)				// if first arg is given...
    checkhelp(pvec, argv[1]);			// see if help is requested
  setarguments(pvec, argv);			// args override defaults
  checkusage(pvec);				// complain if args missing
  paramvec = pvec;				// install parameter vector
  savehistory(pvec);				// save activation record
}

//  __________________________________________________
//  countdefaults: count number of default parameters.

local int countdefaults(string *defv)
{
  int ndefault;
  string *dp;

  ndefault = 0;
  for (dp = defv; *dp != NULL; dp++)		// loop over all defaults
    if (**dp != ';')				// if not a comment
      ndefault++;				// then count one more
  return (ndefault);
}

//  _____________________________________________________________
//  setprogram: initialize the program name as parameter "argv0".

local void setprogram(param *pvec, string argv0)
{
  pvec->name = "argv0";				// install 0th parameter
  pvec->value = argv0;				// set name from argv[0]
  pvec->comment = NULL;				// no comment for now
  pvec->flags = ARGPARAM;			// so user can't reset it
}

//  ______________________________________________________
//  copydefaults: install default parameters and comments.

local void copydefaults(param *pvec, string *defv)
{
  param *pp;
  string *dp, name, value, com;

  pp = pvec;					// start with 0th param
  for (dp = defv; *dp != NULL; dp++)		// loop over the defaults
    if (**dp != ';') {				// if not a comment...
      pp++;					// go on to new param
      name = parname(*dp);			// extract param name
      value = parvalue(*dp);			// and param value
      if (name == NULL || value == NULL)	// any problems found?
	error("%s.initparam: bad parameter %s\n", progname, *dp);
      pp->name = strdup(name);			// assign param name
      pp->value = strdup(value);		// and parameter value
      pp->comment = NULL;			// clear comment field
      pp->flags = DEFPARAM;			// source is default
      if (streq(pp->value, "???"))		// a required param?
	pp->flags |= REQPARAM;			// set required flag
      if (**dp == '<')				// an input parameter?
	pp->flags |= INPARAM;			// set input flag
      else if (**dp == '>')			// an output parameter?
	pp->flags |= OUTPARAM;			// set output flag
    } else if (pp->comment == NULL)	{	// a new comment...
      pp->comment = strdup(*dp + 1);		// assign comment field
    } else {					// more text for comment...
      com = (string) allocate(strlen(pp->comment) + strlen(*dp+1) + 2);
						// get space for comment
      strcpy(com, pp->comment);			// copy existing text
      strcat(com, "\n");			// indicate end of line
      strcat(com, *dp + 1);			// store text of comment
      free(pp->comment);			// free up old space
      pp->comment = com;			// and store new comment
    }
  pp++;						// past last real param
  pp->name = NULL;				// end list of parameters
}

//  __________________________________________________________
//  checkhelp: if requested, print out help mesaages and exit.

local void checkhelp(param *pvec, string arg1)
{
  param *pp;
  char buf[BUFLEN];

  if (streq(arg1, "-clue") || streq(arg1, "--clue")) {
						// print brief help message
    printf("%s", pvec->value);
    for (pp = pvec+1; pp->name != NULL; pp++)
      printf(" %s=%s", pp->name, pp->value);
    printf("\n");
    exit(0);
  }
  if (streq(arg1, "-help") || streq(arg1, "--help")) {
						// print full help message
    printparam(pvec->value, pvec->comment, FALSE);
    for (pp = pvec+1; pp->name != NULL; pp++) {
      sprintf(buf, "  %s=%s", pp->name, pp->value);
      printparam(buf, pp->comment, FALSE);
    }
    exit(0);
  }
  if (streq(arg1, "-explain") || streq(arg1, "--explain")) {
						// print long help message
    printf("\n");
    printparam(pvec->value, pvec->comment, TRUE);
    for (pp = pvec+1; pp->name != NULL; pp++) {
      sprintf(buf, "  %s=%s", pp->name, pp->value);
      printparam(buf, pp->comment, TRUE);
    }
    exit(0);
  }
}

//  _______________________________________________
//  printparam: print parameter and comment string.

local void printparam(string item, string comment, bool explain)
{
  char buf[BUFLEN], *bp1, *bp2;

  if (comment == NULL)
    printf("%s\n", item);
  else {
    strcpy(buf, comment);
    bp1 = strchr(buf, '\n');
    if (bp1 != NULL)
      *bp1++ = (char) NULL;
    printf((strlen(item) < 32 ? "%-32s  %s\n" : "%s\n\t\t\t\t  %s\n"),
	   item, buf);
    if (explain) {
      while (bp1 != NULL) {
	bp2 = strchr(bp1, '\n');
	if (bp2 != NULL)
	  *bp2++ = (char) NULL;
	printf("\t\t\t\t  %s\n", bp1);
	bp1 = bp2;
      }
      printf("\n");
    }
  }
}

//  __________________________________________________________
//  setarguments: replace defaults with commandline arguments.

local void setarguments(param *pvec, string *argv)
{
  bool scanpos;
  param *pp;
  string *ap, name;

  scanpos = TRUE;				// start scan by position
  pp = pvec;					// start with 0th param
  for (ap = argv + 1; *ap != NULL; ap++) {	// loop over the arguments
    name = parname(*ap);			// get param name, if any
    scanpos = scanpos && (name == NULL);	// see how to match args
    if (scanpos) {				// match by position?
      pp++;					// move to next param
      if (pp->name == NULL)			// past last parameter?
	error("%s.initparam: too many arguments\n", progname);
      pp->value = strdup(*ap);			// set new param value
    } else {					// matching by name?
      if (name == NULL)				// but no name given?
	error("%s.initparam: arg %s must be named\n", progname, *ap);
      pp = findparam(name, pvec);		// look for named param
      if (pp == NULL)				// an unknown param?
	error("%s.initparam: parameter %s unknown\n", progname, name);
      if (pp->flags & ARGPARAM)			// already on arg list?
	error("%s.initparam: parameter %s duplicated\n", progname, name);
      pp->value = strdup(parvalue(*ap));	// set new param value
    }
    pp->flags = (pp->flags & ~DEFPARAM) | ARGPARAM;
						// switch source flag
  }
}

//  ___________________________________________
//  checkusage: print out short message on use.

local void checkusage(param *pvec)
{
  bool needarg;
  int len;
  param *pp;
  string args;

  needarg = FALSE;				// see if any args left out
  for (pp = pvec+1; pp->name != NULL; pp++)	// scan list of parameters
    needarg = needarg | ((pp->flags & REQPARAM) && (pp->flags & DEFPARAM));
						// req. param but defaulted?
  if (needarg) {
    len = 0;
    for (pp = pvec+1; pp->name != NULL; pp++)	// estimate space needed
      len += 5 + strlen(pp->name);
    args = (string) allocate(len + 1);
    for (pp = pvec+1; pp->name != NULL; pp++)
      if ((pp->flags & REQPARAM)) {		// is this arg required?
	strcat(args, pp->name);			// add the argument name
	strcat(args, "=??? ");			// and its default value
      }
    error("Usage: %s %s\n", progname, args);
  }
}

//  ____________________________________________
//  savehistory: interface to history mechanism.

local void savehistory(param *pvec)
{
  param *pp;
  int hlen;
  char *hist;

  pp = findparam("HISTORY", pvec);		// look for a history entry
  if (pp != NULL && ! strnull(pp->value)) 	// is history data present?
    add_history(pp->value);			// just send to history pkg
  else {					// format history data
    hlen = strlen(pvec->value);			// count length of argv0
    for (pp = pvec+1; pp->name != NULL; pp++)
						// sum length of others
      if ((pp->flags & ARGPARAM) || streq(pp->name, "VERSION"))
						// actual arg or version?
	hlen += 2 + strlen(pp->name) + strlen(pp->value);
						// add length required
    hist = (char *) allocate(hlen+1);		// get memory for history
    strcpy(hist, pvec->value);			// store program name
    for (pp = pvec+1; pp->name != NULL; pp++)
						// loop over other params
      if ((pp->flags & ARGPARAM) || streq(pp->name, "VERSION")) {
						// actual arg or version?
	strcat(hist, " ");			// insert a space
	strcat(hist, pp->name);			// and the argument name
	strcat(hist, "=");			// and a equals sign
	strcat(hist, pp->value);		// and the argument value
      }
    add_history(hist);				// invoke history package
  }
}

//  ____________________________________
//  getparam: return value of parameter.

string getparam(string name)
{
  param *par;

  if (paramvec == NULL)	{			// called during init?
    if (streq(name, "argv0") && progname != NULL)
      return (progname);			// handle "argv0" specially
    error("getparam: called before initparam\n");
						// program name unknown
  }
  par = findparam(name, paramvec);		// look up value by name
  if (par == NULL)
    error("%s.getparam: parameter %s unknown\n", progname, name);
  return (par->value);
}

//  _______________________________________
//  getiparam: get integer-value parameter.

int getiparam(string name)
{
  string str = getparam(name), end;
  int val;

  val = strtol(str, &end, 0);
  if (end == str)
    error("%s.getiparam: %s=\"%s\" not int\n", progname, name, str);
  if (*end == 'k' || *end == 'K')
    return (1024 * val);
  if (*end == 'm' || *end == 'M')
    return (1024 * 1024 * val);
  return (val);
}

//  ______________________________________________
//  getdparam: get floating-point value parameter.

double getdparam(string name)
{
  string str = getparam(name), end;
  double val1, val2;

  if (sscanf(str, "%lf/%lf", &val1, &val2) == 2)
    return (val1 / val2);
  val1 = strtod(str, &end);
  if (end == str)
    error("%s.getdparam: %s=\"%s\" not double\n", progname, name, str);
  return (val1);
}

//  _________________________________
//  getbparam: get boolean parameter.

bool getbparam(string name)
{
  string str = getparam(name);

  if (strchr("tTyY1", *str) != NULL)		// is value true?
    return (TRUE);
  if (strchr("fFnN0", *str) != NULL)		// is value false?
    return (FALSE);
  error("%s.getbparam: %s=\"%s\" not bool\n", progname, name, str);
  return (FALSE);				// keep compiler happy...
}

//  __________________________________________________________________
//  getparamstat: return parameter flags, or zero if no such parameter
//  (note that all defined parameters have at least one bit set).

int getparamstat(string name)
{
  param *par;

  par = findparam(name, paramvec);
  return (par != NULL ? par->flags : 0);
}

//  __________________________________________________________
//  findparam: look for named parameter in list of parameters.

local param *findparam(string name, param *pvec)
{
  param *pp;

  for (pp = pvec; pp->name != NULL; pp++)
    if (streq(name, pp->name))
      return (pp);
  return (NULL);
}

//  _____________________________________________
//  parname: extract name from name=value string.
//  WARNING:  returns ptr to static storage.

local string parname(string arg)
{
  char *ap, *ep;
  static char namebuf[64];

  ap = (char *) arg;
  if (*ap == '<' || *ap == '>')
    ap++;
  strncpy(namebuf, ap, 63);
  namebuf[63] = (char) NULL;
  ep = strchr(namebuf, '=');
  if (ep == NULL)				// not of form name=value?
    return (NULL);
  *ep = (char) NULL;
  return (namebuf);
}

//  _______________________________________________
//  parvalue: extract value from name=value string.

local string parvalue(string arg)
{
  char *ep;

  ep = strchr(arg, '=');
  if (ep == NULL)
    return (NULL);
  return (ep + 1);
}

#ifdef TESTBED

string defv[] = {		";Program to test getparam.",
				";This program illustrates features of",
				";Zeno's command-line argument passing.",
  "<input=???",			";This parameter is required.",
				";An error occurs if no value is given.",
  ">output=",			";This parameter is not required.",
				";Its default value is null.",
  "answer=42",			";This parameter needs no comment.",
				";Cool froods KNOW the answer is 42!",
				";Decimal, octal, and hex are accepted.",
				";A trailing k or m multiplies the value",
				";by 1024 or 1048576, respectively.",
  "value=10.0",			";This is a floating-point parameter.",
				";Scientific notation is accepted;",
				";a ratio can be specified as value/value.",
  "flag=false",			";This is a boolean parameter.",
				";The first letter determines the value:",
				";\"tTyY1\" -> TRUE, \"fFnN0\" -> FALSE.",
				";Set to TRUE to see error handling.",
  "foobar=waldo_and_mumble_grumble_for_a_while",
				";This parameter is very long.",
				";So the comment starts on the next line.",
  "VERSION=2.4",		";Josh Barnes  8 May 2012",
				";By convention, the current version",
				";appears as the last parameter.",
  NULL,
};

int main(int argc, string *argv)
{
  initparam(argv, defv);
  printf("program %s:\n", getprog());
  printf("  input = \"%s\" [%o]\n", getparam("input"),
	 getparamstat("input"));
  printf("  output = \"%s\" [%o]\n", getparam("output"),
	 getparamstat("output"));
  printf("  answer = %d [%o]\n", getiparam("answer"),
	 getparamstat("answer"));
  printf("  value = %g [%o]\n", getdparam("value"),
	 getparamstat("value"));
  printf("  flag = %s [%o]\n", getbparam("flag") ? "TRUE" : "FALSE",
	 getparamstat("flag"));
  printf("  foobar = \"%s\" [%o]\n", getparam("foobar"),
	 getparamstat("foobar"));
  printf("  VERSION = \"%s\" [%o]\n", getversion(),
	 getparamstat("VERSION"));
  if (getbparam("flag")) {
    printf("getparamstat(\"junk\") = %o\n", getparamstat("junk"));
    printf("calling getparam(\"junk\")\n");
    (void) getparam("junk");
  }
  return (0);
}

#endif
End of getparam.c
echo history.c 1>&2
cat >history.c <<'End of history.c'
/*
 * history.c: routines to handle the history items of structured binary files.
 *	 9-Mar-88	V1.0	Created					PJT
 *	 1-Jun-88	V1.1	renamed read/write to get/put		PJT
 *	 7-jun-88	V1.2	installed in libT with getparam();
 *                              dynamic HISTORY				PJT
 *      14-Jun-88       V1.3    integrated with IAS NEMO		JEB
 *       5-Aug-96       V1.4    removed headlines; added prototyping    JEB
 */

#include "stdinc.h"
#include "getparam.h"
#include "filestruct.h"

#define HistoryTag "History"		// tag for history items	

#define MAXHIST 256			// max size of history array

local string histbuf[MAXHIST+1];	// history string array

local int nhist = 0;			// count of history data stored

//  __________________________________________________________
//  get_history: read history information into history buffer.

void get_history(stream instr)
{
    bool lpflag, inflag;

    lpflag = TRUE;				// get into loop once
    inflag = TRUE;				// read 1st history item
    while (lpflag)				// loop reading input data
	if (get_tag_ok(instr, HistoryTag))	// got a history item?
	    if (inflag) {			// and first in this file?
		add_history(get_string(instr, HistoryTag));
						// then add to record
		inflag = FALSE;
	    } else
		free(get_string(instr, HistoryTag));
						// else, skip history data
	else
	    lpflag = FALSE;			// don't take next loop
}

//  ______________________________________
//  skip_history: read past history items.

void skip_history(stream instr)
{
  while (get_tag_ok(instr, HistoryTag))
    (void) skip_item(instr);
}

//  ________________________________________________________________
//  put_history:  write current history and headline data to output.

void put_history(stream outstr)
{				
    int i;

    for (i = 0; i < nhist; i++)
    	put_string(outstr, HistoryTag, histbuf[i]);
}

//  _______________________________________
//  add_history: add item to history array.

void add_history(string s)
{
    if (nhist < MAXHIST-1)			// enough room for data?
        histbuf[nhist] = s;
    else if (nhist == MAXHIST-1)		// just reached maximum?
        eprintf("[%s.add_history: WARNING: too much history]\n", getprog());
    nhist++;
    histbuf[MIN(nhist,MAXHIST-1)] = NULL;	// terminate w/ NULL
}

//  ________________________________________
//  ask_history: enquire about history data.

string *ask_history(void)
{
    return (histbuf);
}

#ifdef TESTBED

char *defv[] = {		// DEFAULT INPUT PARAMETERS
    "in=???",			// ascii input file name
    "out=",			// if given, output history
    "history=",			// if given, add to history array
    "VERSION=1.3",		// JEB  14 June 1988
    NULL,
};

string iname, oname;			// input/output file  name
stream instr, outstr;

main(int argc, string argv[])
{
    int i;

    initparam(argv, defv);              // initialize command line pars
    iname = getparam("in");
    oname = getparam("out");
    instr = stropen(iname, "r");
    get_history(instr);
    if (! streq(getparam("history"), ""))
	add_history(getparam("history"));
    for (i = 0; i < nhist; i++)
        printf("%3d: %s\n", i, histbuf[i]);
    strclose(instr);
    if (! streq(oname, "")) {
	outstr = stropen(oname, "w");
	put_history(outstr);
	strclose(outstr);
    }
}

#endif
End of history.c
echo mathfns.c 1>&2
cat >mathfns.c <<'End of mathfns.c'
/*
 * mathfns.c: utility routines for various sorts of math operations.
 * Most these functions work with real values, meaning that they can
 * handle either floats or doubles, depending on compiler switches.
 */

#include "stdinc.h"
#include "mathfns.h"

#ifndef TESTBED

//  __________________________________
//  rsqr, rqbe: compute x*x and x*x*x.

real rsqr(real x)
{
    return (x * x);
}

real rqbe(real x)
{
    return (x * x * x);
}

#if defined(SINGLEPREC)

//  __________________________
//  fcbrt: floating cube root.

float fcbrt(float x)
{
    return ((float) cbrt((double) x));
}

#endif

//  ___________________________
//  rdex: inverse log base ten.

real rdex(real x)
{
    return (rexp(M_LN10 * x));
}

#if defined(SINGLEPREC) || !defined(MACOSX)

//  ___________________________________________
//  RLOG2, REXP2: log, inverse log to base two.

real rlog2(real x)
{
    return (rlog(x) / M_LN2);
}

real rexp2(real x)
{
    return (rexp(M_LN2 * x));
}

#endif

#endif // ! TESTBED

#ifdef TESTBED

#include "getparam.h"

string defv[] = {
    "x=2.0",
    "y=1.0",
    "VERSION=0",
    NULL,
};

main(int argc, string argv[])
{
    real x, y;

    initparam(argv, defv);
    x = getdparam("x");
    y = getdparam("y");
#if defined(MIXEDPREC)
    printf("Mixed Precision Version\n");
#endif
#if defined(SINGLEPREC)
    printf("Single Precision Version\n");
#endif
#if defined(DOUBLEPREC)
    printf("Double Precision Version\n");
#endif
    printf("rsqrt(%4.2f)        = %12.8f\n", x, rsqrt(x));
    printf("rcbrt(%4.2f)        = %12.8f\n", x, rcbrt(x));
    printf("rsqr(%4.2f)         = %12.8f\n", x, rsqr(x));
    printf("rqbe(%4.2f)         = %12.8f\n", x, rqbe(x));
    printf("rsin(%4.2f)         = %12.8f\n", x, rsin(x));
    printf("rcos(%4.2f)         = %12.8f\n", x, rcos(x));
    printf("rtan(%4.2f)         = %12.8f\n", x, rtan(x));
    printf("rasin(%4.2f)        = %12.8f\n", x, rasin(x));
    printf("racos(%4.2f)        = %12.8f\n", x, racos(x));
    printf("ratan(%4.2f)        = %12.8f\n", x, ratan(x));
    printf("ratan2(%4.2f,%5.2f) = %12.8f\n", x, y, ratan2(x, y));
    printf("rlog(%4.2f)         = %12.8f\n", x, rlog(x));
    printf("rexp(%4.2f)         = %12.8f\n", x, rexp(x));
    printf("rlog2(%4.2f)        = %12.8f\n", x, rlog2(x));
    printf("rexp2(%4.2f)        = %12.8f\n", x, rexp2(x));
    printf("rlog10(%4.2f)       = %12.8f\n", x, rlog10(x));
    printf("rdex(%4.2f)         = %12.8f\n", x, rdex(x));
    printf("rsinh(%4.2f)        = %12.8f\n", x, rsinh(x));
    printf("rcosh(%4.2f)        = %12.8f\n", x, rcosh(x));
    printf("rtanh(%4.2f)        = %12.8f\n", x, rtanh(x));
    printf("rpow(%4.2f,%5.2f)   = %12.8f\n", x, y, rpow(x, y));
    printf("rabs(%4.2f)         = %12.8f\n", x, rabs(x));
    printf("rfloor(%4.2f)       = %12.8f\n", x, rfloor(x));
    printf("rceil(%4.2f)        = %12.8f\n", x, rceil(x));
}

#endif
End of mathfns.c
echo phatstruct.c 1>&2
cat >phatstruct.c <<'End of phatstruct.c'
/*
 * phatstruct.c: routines for phat structure package.
 */

#include "stdinc.h"
#include "getparam.h"
#include "datatypes.h"
#include "phatstruct.h"
#include <string.h>

//  __________________________________________________________________
//  layout_struct: compute offsets and length of structure.  The order
//  of the actual fields is determined by the names argument.  Padding
//  is computed assuming (1) any type of object can have offset 0, and
//  (2) identical objects of any type can be stored contiguously
//  without padding.

void layout_struct(ps_field *pstab, string *names)
{
  bool debug = (getenv("PHATSTRUCT_DEBUG") != NULL);
  int pad, len;
  ps_field *psp;

  pad = 0;
  while (*names != NULL) {			// loop over field names
    for (psp = pstab + 1; psp->name != NULL; psp++)
      if (streq(psp->name, *names))		// find name in struct tab
	break;
    if (psp->name == NULL)			// must already be known
      error("%s.layout_struct: field %s not found\n", getprog(), *names);
    if (psp->offset == BadOffset) {		// if not already defined
      len = type_length(type_base(psp->type));	// get length of base type
      while (pstab->length % len != 0) {	// align on proper boundary
	pstab->length++;
	pad++;
      }
      psp->offset = pstab->length;		// assign offset and length
      psp->length = type_length(psp->type);
      pstab->length += psp->length;		// increment struct length
      if (debug)
	eprintf("[%s.layout_struct: defining %s field %s at offset %d]\n",
		getprog(), strlen(psp->type) == 1 ? "scalar" : "vector",
		*names, psp->offset);
    }
    names++;
  }
  len = sizeof(int);				// take int as minimum
  for (psp = pstab + 1; psp->name != NULL; psp++)
    if (psp->offset != BadOffset)
      len = MAX(len, type_length(type_base(psp->type)));
  while (pstab->length % len != 0) {		// align complete structure
    pstab->length++;
    pad++;
  }
  if (debug)
    eprintf("[%s.layout_struct: sizeof(%s) = %d bytes (%d padding)]\n",
	    getprog(), pstab->name, pstab->length, pad);
}

//  _________________________________________________________________________
//  new_field: define a new field of given type and name.  Note that it is up
//  to the client to make sure that the field array is properly terminated.

void new_field(ps_field *psptr, string type, string name)
{
  psptr->name = name;				// name is given by caller
  psptr->type = type;				// type is given by caller
  psptr->offset = BadOffset;			// offset is yet unknown
  psptr->length = 0;				// and length is undefined
}

//  ___________________________________________________________________
//  define_struct: set total length of structure; a partial alternative
//  to layout_struct for the fixed offset interface.

void define_struct(ps_field *pstab, string name, int length)
{
  if (! streq(pstab->name, name))
    error("%s.define_struct: structure %s not found\n", getprog(), name);
  pstab->length = length;
  if (getenv("PHATSTRUCT_DEBUG") != NULL)
    eprintf("[%s.define_struct: sizeof(%s) = %d bytes]\n",
	    getprog(), pstab->name, pstab->length);
}

//  __________________________________________________________________
//  define_offset: set offset of known field; a partial alternative to
//  layout_struct for the fixed offset interface.

void define_offset(ps_field *pstab, string name, int offset)
{
  ps_field *psp;

  for (psp = pstab + 1; psp->name != NULL; psp++)
    if (streq(psp->name, name))			// find name in struct tab
      break;
  if (psp->name == NULL)			// must be already known
    error("%s.define_field: field %s not found\n", getprog(), name);
  if (psp->offset != BadOffset)			// but not actual
    error("%s.define_field: field %s already defined\n",
	  getprog(), name);
  psp->offset = offset;				// store supplied offset
  psp->length = type_length(psp->type);
  if (getenv("PHATSTRUCT_DEBUG") != NULL)
    eprintf("[%s.define_field: defining %s field %s at offset %d]\n",
	    getprog(), strlen(psp->type) == 1 ? "scalar" : "vector",
	    name, psp->offset);
}    

#ifdef TESTBED

#include "getparam.h"

string defv[] = {		";Test phat structures",
    "fields=foo,bar,fum,fie,baz,jojo",
				";List of structure fields",
    "VERSION=1.0",		";Josh Barnes  18 July 1994",
    NULL,
};

ps_field phatstruct[] = {
    { NULL,               "foobar",  0,          0 },
    { CharType,           "foo",     BadOffset,  0 },
    { ShortType,          "bar",     BadOffset,  0 },
    { IntType,            "fum",     BadOffset,  0 },
    { FloatType,          "fie",     BadOffset,  0 },
    { DoubleType,         "baz",     BadOffset,  0 },
    { RealType RealType,  "jojo",    BadOffset,  0 },
    { NULL,               NULL,      0,          0 },
};

#define Foo(x)  SelectChar(x, phatstruct[1].offset)
#define Bar(x)  SelectShort(x, phatstruct[2].offset)
#define Fum(x)  SelectInt(x, phatstruct[3].offset)
#define Fie(x)  SelectFloat(x, phatstruct[4].offset)
#define Baz(x)  SelectDouble(x, phatstruct[5].offset)
#define Jojo(x) SelectVect(x, phatstruct[6].offset)

main(int argc, string argv[])
{
    string *fields;
    void *xp;

    initparam(argv, defv);
    fields = burststring(getparam("fields"), ",");
    layout_struct(phatstruct, fields);
    xp = allocate(phatstruct[0].length);
    Foo(xp) = 'a';
    Bar(xp) = 123;
    Fum(xp) = 12345678;
    Fie(xp) = 3.141592;
    Baz(xp) = 2.718281;
    Jojo(xp)[0] = 1.5;
    Jojo(xp)[1] = -2.5;
    printf("xp -> { %c  %d  %d  %f  %f [%f %f] }\n", Foo(xp), Bar(xp),
	   Fum(xp), Fie(xp), Baz(xp), Jojo(xp)[0], Jojo(xp)[1]);
}

#endif
End of phatstruct.c
echo pickpnt.c 1>&2
cat >pickpnt.c <<'End of pickpnt.c'
/*
 * pickpnt.c: pick points at random in various distributions.
 */

#include "stdinc.h"
#include "mathfns.h"

//  _______________________________
//  pickshell: pick point on shell.

void pickshell(real vec[], int ndim, real rad)
{
    real rsq, rscale;
    int i;

    do {
	rsq = 0.0;
	for (i = 0; i < ndim; i++) {
	    vec[i] = xrandom(-1.0, 1.0);
	    rsq = rsq + vec[i] * vec[i];
	}
    } while (rsq > 1.0);
    rscale = rad / rsqrt(rsq);
    for (i = 0; i < ndim; i++)
	vec[i] = vec[i] * rscale;
}

//  _________________________________
//  pickball: pick point within ball.

void pickball(real vec[], int ndim, real rad) 
{
    real rsq;
    int i;

    do {
	rsq = 0.0;
	for (i = 0; i < ndim; i++) {
	    vec[i] = xrandom(-1.0, 1.0);
	    rsq = rsq + vec[i] * vec[i];
	}
    } while (rsq > 1.0);
    for (i = 0; i < ndim; i++)
	vec[i] = vec[i] * rad;
}

//  _______________________________
//  pickbox: pick point within box.

void pickbox(real vec[], int ndim, real size) 
{
    int i;

    for (i = 0; i < ndim; i++)
	vec[i] = xrandom(- size, size);
}
End of pickpnt.c
echo random.c 1>&2
cat >random.c <<'End of random.c'
/*
 * random.c: useful functions for random numbers.
 */

#include "stdinc.h"
#include "mathfns.h"
#include "getparam.h"
#include <string.h>
#include <gsl/gsl_rng.h>

local gsl_rng *rng = NULL;
local unsigned long rng_min, rng_max;

//  __________________________________________________________________
//  init_random: select and initialize random number generator.  For
//  backward compatibility, default reproduces unix random() function;
//  set GSL_RNG_TYPE environment variable to select better generators.

void init_random(unsigned long seed)
{
  if (rng == NULL) {				// select on first call
    if (getenv("GSL_RNG_TYPE") != NULL && !strnull(getenv("GSL_RNG_TYPE"))) {
      rng = gsl_rng_alloc(gsl_rng_env_setup());
      eprintf("[%s.init_random: generator %s, range %lu:%lu]\n", getprog(),
	      gsl_rng_name(rng), gsl_rng_min(rng), gsl_rng_max(rng));
    } else
      rng = gsl_rng_alloc(gsl_rng_random128_glibc2);
  }
  rng_min = gsl_rng_min(rng);
  rng_max = gsl_rng_max(rng);
  gsl_rng_set(rng, seed);
}

//  __________________________________________________________________
//  xrandom: floating-point random number in range [xl,xh], inclusive;
//  computed by scaling unsigned long, so at most 32 bits are random.

double xrandom(double xl, double xh)
{
  if (rng == NULL) {
    eprintf("[%s.xrandom: WARNING: using default seed]\n", getprog());
    init_random(0);
  }
  return (xl + (xh - xl) *
	    (gsl_rng_get(rng) - rng_min) / ((double) (rng_max - rng_min)));
}

//  ___________________________________________________________
//  grandom: normally distributed random number (polar method).
//  Reference: Knuth, vol. 2, p. 104.

double grandom(double mean, double sdev)
{
  double v1, v2, s;

  do {
    v1 = xrandom(-1.0, 1.0);
    v2 = xrandom(-1.0, 1.0);
    s = v1*v1 + v2*v2;
  } while (s >= 1.0);
  return (mean + sdev * v1 * sqrt(-2.0 * log(s) / s));
}

//  _________________________________________________________________
//  get_random_state: get snapshot of current random generator state.
//  State pointer *st must be initialized to NULL before first call.

void get_random_state(int *nb, void **st)
{
  if (*st == NULL) {
    *nb = (int) gsl_rng_size(rng);
    *st = (void *) allocate(*nb);
  } else if (*nb != (int) gsl_rng_size(rng))
    error("%s.get_random_state: inconsistent state size\n", getprog());
  memcpy(*st, gsl_rng_state(rng), *nb);
}

//  _______________________________________________________________
//  set_random_state: copy state snapshot back to random generator.

void set_random_state(int *nb, void **st)
{
  if (rng == NULL)
    init_random(0);				// make sure rng exists
  if (*nb != (int) gsl_rng_size(rng))
    error("%s.set_random_state: inconsistent state size\n", getprog());
  memcpy(gsl_rng_state(rng), *st, *nb);
}

#if defined(TESTBED)

string defv[] = {
  "seed=123",
  "count=10",
  "state=false",
  NULL,
};

int main(int argc, string argv[])
{
  int n, nb;
  double x;
  void *st = NULL;

  initparam(argv, defv);
  init_random(getiparam("seed"));
  for (n = getiparam("count"); n > 0; n--) {
    x = xrandom(0.0, 1.0);
    printf("xrandom(0,1) -> %.15f (%a)\n", x, x);
  }
  if (getbparam("state")) {
    get_random_state(&nb, &st);
    printf("state size: %d bytes\n", nb);
    printf("state: ");
    for (n = 0; n < nb; n++)
      printf("%02x%c", ((byte *) st)[n], n < nb-1 ? ' ' : '\n');
    for (n = getiparam("count"); n > 0; n--) {
      x = xrandom(0.0, 1.0);
      printf("xrandom(0,1) -> %.15f (%a)\n", x, x);
    }
    printf("resetting random state\n");
    set_random_state(&nb, &st);
    for (n = getiparam("count"); n > 0; n--) {
      x = xrandom(0.0, 1.0);
      printf("xrandom(0,1) -> %.15f (%a)\n", x, x);
    }
  }
  return (0);
}

#endif
End of random.c
echo scanopt.c 1>&2
cat >scanopt.c <<'End of scanopt.c'
/*
 * scanopt.c: scan string of the form "word1,word2,..." for match. Warning:
 * words must be separated by exactly one comma -- no spaces allowed!
 */

#include "stdinc.h"

bool scanopt(string opt, string key)
{
    char *op, *kp;

    op = (char *) opt;				// start scan of options
    while (*op != (char) NULL) {		// loop over words
	kp = key;
	while ((*op != ',' ? *op : (char) NULL) == *kp) {
						// compare with key
	  if (*kp++ == (char) NULL)
		return (TRUE);			// found keyword
	    op++;
	}
	while (*op != (char) NULL &&
	         *op++ != ',')			// scan for next word
	    continue;
    }
    return (FALSE);				// keyword not found
}

#ifdef TESTBED

#include "getparam.h"

string defv[] = {
    "opt=foo,bar,fum",
    "key=foo",
    NULL,
};

void main(int argc, string argv[])
{
    string opt, key;

    initparam(argv, defv);
    opt = getparam("opt");
    key = getparam("key");
    printf("scanopt(\"%s\", \"%s\") returns %s\n",
	   opt, key, scanopt(opt, key) ? "true" : "false");
}

#endif
End of scanopt.c
echo setrange.c 1>&2
cat >setrange.c <<'End of setrange.c'
/*
 * setrange.c: parse range a expression and assign values.  The range
 * expression has the form
 *
 *	range = <value>:<value> | <value> | <value>:
 *	value = <number> | <number>/<number>
 *
 * In a range expression with only one <value>, the other is taken
 * to be zero; <value> is interpreted as 0:<value>, while <value>:
 * is interpreted as <value>:0.
 */

#include "stdinc.h"
#include "mathfns.h"
#include <stdlib.h>

void setrange(real *rval, string rexp)
{
    string rptr;
    
    rval[0] = strtod(rexp, &rptr);
    if (*rptr == '/')
	rval[0] = rval[0] / strtod(rptr + 1, &rptr);
    if (*rptr == ':') {
	rval[1] = strtod(rptr + 1, &rptr);
	if (*rptr == '/')
	    rval[1] = rval[1] / strtod(rptr + 1, &rptr);
    } else {
	rval[1] = rval[0];
	rval[0] = 0.0;
    }
    if (*rptr != (char) NULL)
	eprintf("[%s.setrange: WARNING: ignoring trailing \"%s\"]\n",
		getprog(), rptr);
}

#ifdef TESTBED

#include "getparam.h"

string defv[] = {
    "range=1/64:3.2e1",
    NULL,
};

main(int argc, string *argv)
{
    real range[2];

    initparam(argv, defv);
    setrange(range, getparam("range"));
    printf("%s: %s -> %f,%f\n", getprog(), getparam("range"),
	   range[0], range[1]);
}

#endif
End of setrange.c
echo spline.c 1>&2
cat >spline.c <<'End of spline.c'
/*
 * spline.c: functions to evaluate cubic spline approximations.
 * Reference: Forsythe, Malcolm & Moler, "Computer Methods for
 *	      Mathematical Computations", pp. 76-79.
 */

#include "stdinc.h"
#include "mathfns.h"
#include "getparam.h"

local void splsub(real *, real *, real *, real *, real *, int);

//  ___________________________________
//  spline: compute cubic spline coefs.

void spline(real *coef, real *x, real *y, int n)
{
    splsub(&coef[0], &coef[n], &coef[2*n], x, y, n);
}

local void splsub(real *b, real *c, real *d, real *x, real *y, int n)
{
    int i;
    real t1, tn, t;

    if (n < 3)
        error("%s.spline: n lt 3\n", getprog());
    d[0] = x[1] - x[0];
    c[1] = (y[1] - y[0]) / d[0];
    for (i = 1; i <= n-2; i++) {
        d[i] = x[i+1] - x[i];
        b[i] = 2.0 * (d[i-1] + d[i]);
        c[i+1] = (y[i+1] - y[i]) / d[i];
        c[i] = c[i+1] - c[i];
    }
    b[ 0 ] = - d[ 0 ];
    b[n-1] = - d[n-2];
    if (n == 3)
        c[0] = c[n-1] = 0.0;
    else {
        t1 = c[ 2 ] / (x[ 3 ] - x[ 1 ]) - c[ 1 ] / (x[ 2 ] - x[ 0 ]);
        tn = c[n-2] / (x[n-1] - x[n-3]) - c[n-3] / (x[n-2] - x[n-4]);
        c[ 0 ] =   t1 * d[ 0 ]*d[ 0 ] / (x[ 3 ] - x[ 0 ]);
        c[n-1] = - tn * d[n-2]*d[n-2] / (x[n-1] - x[n-4]);
    }
    for (i = 1; i <= n-1; i++) {
        t = d[i-1] / b[i-1];
        b[i] = b[i] - t * d[i-1];
        c[i] = c[i] - t * c[i-1];
    }
    c[n-1] = c[n-1] / b[n-1];
    for (i = n-2; i >= 0; i--)
        c[i] = (c[i] - d[i] * c[i+1]) / b[i];
    b[n-1] = (y[n-1] - y[n-2]) / d[n-2] + d[n-2] * (c[n-2] + 2 * c[n-1]);
    for (i = 0; i <= n-2; i++) {
        b[i] = (y[i+1] - y[i]) / d[i] - d[i] * (c[i+1] + 2 * c[i]);
        d[i] = (c[i+1] - c[i]) / d[i];
        c[i] = 3 * c[i];
    }
    c[n-1] = 3 * c[n-1];
    d[n-1] = d[n-2];
}

//  ___________________________________________
//  seval: evaluate cubic spline interpolation.

real seval(real x0, real *x, real *y, real *coef, int n)
{
    int i, j, k;
    real u;

    i = 0;
    k = n;
    while (i+1 < k) {
        j = (i + k) / 2;
        if (x[j] <= x0)
            i = j;
        else
            k = j;
    }
    u = x0 - x[i];
    return (y[i] + u * (coef[i] + u * (coef[n+i] + u * coef[2*n+i])));
}

//  ____________________________________________
//  spldif: evaluate derivative of cubic spline.

real spldif(real x0, real *x, real *y, real *coef, int n)
{
    int i, j, k;
    real u;

    i = 0;
    k = n;
    while (i+1 < k) {
        j = (i + k) / 2;
        if (x[j] <= x0)
            i = j;
        else
            k = j;
    }
    u = x0 - x[i];
    return (coef[i] + u * (2.0*coef[i+n] + u * 3.0*coef[i+2*n]));
}

#ifdef TESTBED

#define N       11

#define fun(x0) (rsqrt(x0) * rcos(PI*x0))
#define fpr(x0) (0.5*rcos(PI*x0) / rsqrt(x0) - rsqrt(x0) * PI*rsin(PI*x0))

void main(int argc, string argv[])
{
    int i;
    real x[N], y[N], coef[3*N];
    double x0;

    for (i = 0; i < N; i++) {
        x[i] = i / (N - 1.0);
        y[i] = fun(x[i]);
    }
    spline(coef, x, y, N);
    printf("\n%12s%12s%12s%12s%12s\n", "x", "y", "b", "c", "d");
    for (i = 0; i < N; i++) {
        printf("%12.6f%12.6f%12.6f%12.6f%12.6f\n",
               x[i], y[i], coef[i], coef[N+i], coef[2*N+i]);
    }
    printf("\n");
    for ( ; ; ) {
        printf("x0: ");
        scanf("%lf", &x0);
	printf("        %12s\t%12s\n", "f(x)", "f'(x)");
	printf("exact   %12.6f\t%12.6f\n", fun(x0), fpr(x0));
	printf("spline  %12.6f\t%12.6f\n",
	       seval(x0, x, y, coef, N),
	       spldif(x0, x, y, coef, N));
    }
}

#endif
End of spline.c
echo stropen.c 1>&2
cat >stropen.c <<'End of stropen.c'
/*
 * stropen.c: stream-open enhancement of fopen function.
 */

#include "stdinc.h"
#include "getparam.h"
#include <sys/types.h>
#include <sys/stat.h>

//  ___________________________________________________________________
//  stropen: open a stdio stream like fopen(), with these extensions:
//  1.  error checking: stropen() can only return NULL if mode == "r?";
//  2.  data protection: files can only be clobbered if mode == "w!";
//  3.  names of the form "-" map to stdin/stdout, depending on mode;
//  4.  names of the form "-num" open a stream to read/write f.d. num.

stream stropen(string name, string xmode)
{
    bool readflag, testflag;
    char mode[2];
    int fds;
    stream res;
    struct stat buf;

    if (! (streq(xmode, "r") || streq(xmode, "r?") ||
	     streq(xmode, "w") || streq(xmode, "w!") ||
	       streq(xmode, "a")))
	error("%s.stropen: illegal xmode \"%s\"\n",
	      getprog(), xmode);
    readflag = (xmode[0] == 'r');
    testflag = (xmode[1] == '?');
    mode[0] = xmode[0];
    mode[1] = (char) NULL;
    if (name[0] == '-') {			
	if (streq(name, "-")) {
	    fds = dup(fileno(readflag ? stdin : stdout));
	    if (fds == -1)
		error("%s.stropen: cannot dup %s\n",
		      getprog(), readflag ? "stdin" : "stdout");
	} else if (sscanf(name, "-%d", &fds) != 1)
	    error("%s.stropen: bad f.d. number \"%s\"\n",
		  getprog(), name);
	res = fdopen(fds, mode);
	if (res == NULL && !testflag)
	    error("%s.stropen: cannot open f.d. %d for %s\n",
		  getprog(), fds, readflag ? "input" : "output");
    } else {
	if (streq(xmode, "w") && stat(name, &buf) == 0)
	    error("%s.stropen: file \"%s\" already exists\n",
		  getprog(), name);
	res = fopen(name, mode);
	if (res == NULL && !testflag)
	    error("%s.stropen: cannot open file \"%s\" for %s\n",
		  getprog(), name, readflag ? "input" : "output");
    }
    return (res);
}

#ifdef TESTBED

string defv[] = {
    "name=foo.bar",
    "mode=w",
    "text=boo hoo foo",
    NULL,
};

void main(int argc, string argv[])
{
    string name, mode, text;
    stream str;
    char buf[128];

    initparam(argv, defv);
    name = getparam("name");
    mode = getparam("mode");
    text = getparam("text");
    str = stropen(name, mode);
    if (str == NULL)
	error("%s: stropen() returned NULL\n", getprog());
    if (streq(mode, "r") || streq(mode, "r?")) {
	while (fgets(buf, 127, str) != NULL)
	    printf("%s", buf);
    } else {
	sprintf(buf, "%s\n", text);
	fputs(buf, str);
    }
    fclose(str);
}

#endif
End of stropen.c
echo strset.c 1>&2
cat >strset.c <<'End of strset.c'
/*
 * strset.c: code for simple string set package.
 */

#include "stdinc.h"
#include "strset.h"
#include "getparam.h"

#include <stdarg.h>

//  _____________________________________________________________________
//  Sets of strings are represented by null-terminated vectors of string
//  pointers.  This strategy keeps the code simple, but also implies
//  that many operations (construction, union, intersection, difference)
//  are O(N^2) in the number of elements.  The maximum number of elements
//  is therefore limited to a relatively small value.

#define MaxElements  64

//  __________________________________________________________________
//  set_cons: construct a set from a null-terminated list of elements.

string *set_cons(string first, ...)
{
    int n;
    string name, strs[MaxElements+1];
    va_list ap;

    n = 0;
    strs[n++] = first;
    strs[n] = NULL;
    va_start(ap, first);
    while ((name = va_arg(ap, string)) != NULL)
        if (set_member(strs, name))
	    eprintf("[%s.set_cons: WARNING: element %s duplicated]\n",
		    getprog(), name);
        else {
	    if (n == MaxElements)
	        error("%s.set_cons: too many elements\n", getprog());
	    strs[n++] = name;
	    strs[n] = NULL;
	}
    va_end(ap);
    return (set_copy(strs));
}

//  ____________________________________________
//  set_copy: copy set (but not member strings).

string *set_copy(string *set)
{
    return ((string *) copxstr(set, sizeof(string)));
}

//  ________________________________________
//  set_length: return count of set members.

int set_length(string *set)
{
    return (xstrlen(set, sizeof(string)) - 1);
}

//  _____________________________________________
//  set_member: test if element is member of set.

bool set_member(string *set, string element)
{
    string *sp;

    for (sp = set; *sp != NULL; sp++)
        if (streq(*sp, element))
	    return (TRUE);
    return (FALSE);
}

//  ___________________________________________________________
//  set_subset: return true if every member of set2 is in set1.

bool set_subset(string *set1, string *set2)
{
    string *sp;

    for (sp = set2; *sp != NULL; sp++)
        if (! set_member(set1, *sp))
	    return (FALSE);
    return (TRUE);
}

//  _________________________________________________
//  set_equal: return true if sets have same members.

bool set_equal(string *set1, string *set2)
{
    return (set_subset(set1, set2) && set_subset(set2, set1));
}

//  _______________________________________
//  set_union: construct union of two sets.

string *set_union(string *set1, string *set2)
{
    int n;
    string *sp, strs[MaxElements+1];

    n = 0;
    for (sp = set1; *sp != NULL; sp++)
        strs[n++] = *sp;
    for (sp = set2; *sp != NULL; sp++)
        if (! set_member(set1, *sp)) {
	    if (n > MaxElements)
	        error("%s.set_union: too many elements\n", getprog());
	    strs[n++] = *sp;
	}
    strs[n] = NULL;
    return (set_copy(strs));
}

//  ______________________________________________
//  set_inter: construct intersection of two sets.

string *set_inter(string *set1, string *set2)
{
    int n;
    string *sp, strs[MaxElements+1];

    n = 0;
    for (sp = set2; *sp != NULL; sp++)
        if (set_member(set1, *sp))
	    strs[n++] = *sp;
    strs[n] = NULL;
    return (set_copy(strs));
}

//  ___________________________________________
//  set_diff: construct difference of two sets.

string *set_diff(string *set1, string *set2)
{
    int n;
    string *sp, strs[MaxElements+1];

    n = 0;
    for (sp = set1; *sp != NULL; sp++)
        if (! set_member(set2, *sp))
	    strs[n++] = *sp;
    strs[n] = NULL;
    return (set_copy(strs));
}

#ifdef TESTBED

#include "getparam.h"

string defv[] = {
    "set1=foo,bar,fum,fie",
    "set2=fie,bar,waldo,frodo",
    "VERSION=1.0",
    NULL,
};

void print_set(string, string *);

void main(int argc, string argv[])
{
    string *set1, *set2;

    initparam(argv, defv);
    set1 = burststring(getparam("set1"), ", ");
    set2 = burststring(getparam("set2"), ", ");
    printf("set_length(set1) = %d\n", set_length(set1));
    printf("set_subset(set1,set2) = %s\n",
	   set_subset(set1, set2) ? "TRUE" : "FALSE");
    printf("set_equal(set1,set2) = %s\n",
	   set_equal(set1, set2) ? "TRUE" : "FALSE");
    print_set("set_copy(set1):", set_copy(set1));
    print_set("set_union(set1,set2):", set_union(set1, set2));
    print_set("set_inter(set1,set2):", set_inter(set1, set2));
    print_set("set_diff(set1,set2):", set_diff(set1, set2));
}

void print_set(string label, string *set)
{
    string *sp;

    printf("%s", label);
    for (sp = set; *sp != NULL; sp++)
        printf(" %s", *sp);
    printf("\n");
}

#endif // TESTBED
End of strset.c
echo vectmath.c 1>&2
cat >vectmath.c <<'End of vectmath.c'
/*
 * vectmath.c: source code for vector/matrix operations.
 * Joshua Barnes  2 Aug 1996   Honolulu, HI.
 */

#include "stdinc.h"
#include "mathfns.h"
#include "vectdefs.h"

real _dotvp(real *v, real *u, int n)
{
    real s;

    s = 0.0;
    while (--n >= 0)
	s += (*v++) * (*u++);
    return (s);
}

real _absv(real *v, int n)
{
    real s;

    s = 0.0;
    while (--n >= 0) {
	s += (*v) * (*v);
	v++;
    }
    return (rsqrt(s));
}

real _distv(real *v, real *u, int n)
{
    real d, s;

    s = 0.0;
    while (--n >= 0) {
	d = (*v++) - (*u++);
	s += d * d;
    }
    return (rsqrt(s));
}

real _tracem(real *p, int n)
{
    real s;
    int i;

    s = 0.0;
    for (i = n; --i >= 0; ) {
	s += (*p);
	p += (n + 1);			// next diag. element
    }
    return (s);
}
End of vectmath.c
echo vectmath_test.c 1>&2
cat >vectmath_test.c <<'End of vectmath_test.c'
/*
 * vecttest.c: test operators in vectmath.h.
 */

#include "stdinc.h"
#include "mathfns.h"
#include "vectmath.h"

local void prints(string m, double s1, double s2);
local void printv(string m, vector v);
local void printm(string m, matrix p);

vector ex, ey, ez, v, u, w;
matrix I, p, q, r;
real s;

void main(int argc, string argv[])
{
    UNITV(ex, 0);		printv("ex", ex);
    UNITV(ey, 1); 		printv("ey", ey);
    UNITV(ez, 2); 		printv("ez", ez);
    MULVS(v, ex, 3.141592); 	printv("v = ex * pi", v);
    ADDV(u, v, ez); 		printv("u = v + ez", u);
    SUBV(w, u, ey); 		printv("w = u - ey", w);
    DOTVP(s, w, ex); 		prints("s = w . ex", s, dotvp(w, ex));
    DOTVP(s, w, ey); 		prints("s = w . ey", s, dotvp(w, ey));
    DOTVP(s, w, ez); 		prints("s = w . ez", s, dotvp(w, ez));
    ABSV(s, w); 		prints("|w|", s, absv(w));
    DISTV(s, w, ex); 		prints("|w - ex|", s, distv(w, ex));
    DISTSQV(s, w, v);		prints("|w - v|^2", s, rsqr(distv(w, v)));
    CROSSVP(v, ex, ey); 	printv("v = ex x ey", v);
    CROSSVP(u, w, ez); 		printv("u = w x ez", u);
    SETMI(I); 			printm("I", I);
    OUTVP(p, v, ex); 		printm("p = v @ ex", p);
    OUTVP(q, w, u); 		printm("q = w @ u", q);
    ADDM(r, p, q);		printm("r = p + q", r);
    TRANM(p, q);		printm("p = transpose(q)", p);
    MULM(q, p, r);		printm("q = p * r", q);
    MULMV(v, q, w);		printv("v = q . w", v);
    MULMV(u, r, w);		printv("u = r . w", u);
    MULMV(v, p, u);		printv("v = p . u", v);
    TRACEM(s, q);		prints("s = Tr(q)", s, tracem(q));
}

local void prints(string m, double s1, double s2)
{
    printf("\n%-24s: %12.6f%12.6f\n\n", m, s1, s2);
}

local void printv(string m, vector v)
{
    printf("\n%-24s: %12.6f%12.6f%12.6f\n\n", m, v[0], v[1], v[2]);
}

local void printm(string m, matrix p)
{
    printf("\n%-24s  %12.6f%12.6f%12.6f\n"  , "", p[0][0], p[0][1], p[0][2]);
    printf(  "%-24s: %12.6f%12.6f%12.6f\n"  ,  m, p[1][0], p[1][1], p[1][2]);
    printf(  "%-24s  %12.6f%12.6f%12.6f\n\n", "", p[2][0], p[2][1], p[2][2]);
}
End of vectmath_test.c
echo within.c 1>&2
cat >within.c <<'End of within.c'
/*
 * within.c: determine if a floating point number is within specified range,
 * represented as a string of the form "<subrange1>,<subrange2>,..." where
 * each <range> is either a single floating point number, or a pair of
 * numbers seperated by a ":".  To allow for small uncertainties in the
 * values tested, floating-point comparison is done with a specified
 * fuzzyness parameter.
 */

#include "stdinc.h"
#include <string.h>

bool within(double val, string range, double fuzz)
{
    char *endptr, *subptr, *sepptr, *colptr;
    double sublow, subhi;

    endptr = range + strlen(range);		// point to term. NULL
    for (subptr = range; subptr != endptr; ) {	// for each subrange
        sepptr = strchr(subptr, ',');		// pnt to subrange end
	if (sepptr == NULL)			// last subrange listed?
	    sepptr = endptr;			// fix up subend ptr
	colptr = strchr(subptr, ':');		// scan subrange for
	if (colptr > sepptr)			// in another subrange?
	    colptr = NULL;			// then dont use it
	sublow = atof(subptr) - fuzz/2.0;	// set low end of range
	if (colptr != NULL)			// high end specified?
	    subhi = atof(colptr+1) + fuzz/2.0;	// set high end
	else
	    subhi = sublow + fuzz;		// just use low end
	if (sublow <= val && val <= subhi)	// within subrange?
	    return (TRUE);
	subptr = sepptr;			// advance subrange ptr
	if (*subptr == ',')			// more ranges to do?
	    subptr++;				// move on to next
    }
    return (FALSE);
}

#ifdef TESTBED

#include "getparam.h"

string defv[] = {
    "val=1.0",
    "range=0.5:0.7,1.0,1.2:1.3",
    "fuzz=0.001",
    NULL,
};

void main(int argc, string argv[])
{
    initparam(argv, defv);
    if (within(getdparam("val"), getparam("range"), getdparam("fuzz")))
        printf("within returns TRUE\n");
    else
        printf("within returns FALSE\n");
}

#endif
End of within.c
